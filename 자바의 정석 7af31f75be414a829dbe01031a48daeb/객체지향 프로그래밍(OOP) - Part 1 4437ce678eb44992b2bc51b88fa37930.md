# 객체지향 프로그래밍(OOP) - Part 1

2022.07.06

이제 드디어 자바의 메인 디쉬인 객체지향 프로그래밍, OOP에 대하여 알아보겠습니다. 자바의 핵심이고 근간인 만큼 자바의 정석 책에서도 이 부분은 두 파트로 나눠서 설명하고 있습니다. 저도 동일하게 각 파트를 정리한 내용을 여기에 담아보겠습니다.

## 객체지향언어(Object Oriented)

초기에 컴퓨터는 일반인들보다는 과학 실험이나 미사일 발사 실험 같은 전문적인 모의 실험의 목적으로 사용되었습니다. 이러한 모의 실험의 경우에는 **실제 세계를 최대한 동일하게 컴퓨터 내에서 구현하는 것이 중요**했습니다. 그래야 모의 실험의 결과값을 바탕으로 실제 세계에서 미사일을 더 발전시키든가 보완하든가 할 수 있기 때문이죠. 이 생각에서 등장한 프로그래밍 패러다임이 **객체지향이론**입니다. 

객체지향이론의 핵심은 **이 세상의 모든 것은 객체(Object)**라는 것입니다. 생각해보죠. 우리가 지금 사용하고 있는 이 컴퓨터도 하나의 객체입니다. 키보드도, 스마트폰도 모두 객체입니다. 그리고 실제 세계에서 벌어지는 **모든 사건은 모두 객체의 상호작용**입니다. 제가 작성하고 있는 이 글이 노션에 적히는 것은 키보드와 컴퓨터 간의 상호작용이라고 할 수 있습니다.

객체지향언어는 기존의 프로그래밍 언어에 몇 가지 새로운 규칙을 추가하여 코드 설계를 더욱 발전시킨 언어입니다. 그 규칙은 변수와 변수 간의 관계, 변수와 함수 간의 관계를 맺어줌으로써 보다 유기적으로 프로그램을 작성할 수 있도록 해주었습니다. 객체지향언어의 주요 특징은 다음과 같습니다.

1. 코드의 재사용성이 높다.
    - 기존의 코드를 이용하여 쉽게 코드를 작성할 수 있습니다.
2. 코드의 관리가 용이하다.
    - 변수와 변수, 함수 간의 관계를 이용하여 쉽게 코드를 유지보수할 수 있습니다. (유연성)
3. 신뢰성이 높은 프로그래밍을 가능하게 한다.
    - 제어자와 메서드를 이용하여 데이터를 보호할 수 있으며 코드의 중복을 제거하여 오동작의 가능성을 줄일 수 있습니다.
    

그러면 지금부터 자바를 가지고 어떻게 객체지향 프로그래밍을 할 수 있는지 알아보겠습니다.

## 클래스와 객체

우리가 어떠한 물건을 만들기 위해서는 그 물건의 설계도가 필요합니다. 그래야 우리가 원하는 물건을 정확히 만들 수 있고, 추후에 물건을 더 만들어야 한다면 그 설계도를 가지고 쉽게 만들 수 있습니다. 객체지향의 가장 핵심인 클래스와 객체는 설계도와 물건의 관계라고 말할 수 있습니다. **클래스는 객체를 정의해놓은 것, 객체의 설계도**라고 말할 수 있으며, **객체는 클래스에 정의된 내용대로 메모리에 생성된 것**을 의미합니다. 그리고 클래스를 통하여 **객체를 만드는 과정을 인스턴스화(instantiate)**라고 하며, 생성된 객체를 **해당 클래스의 인스턴스(instance)**라고 합니다(객체와 인스턴스는 동일한 의미라고 생각하시면 됩니다). 여기서 객체지향 언어의 첫번째 특징인 재사용성을 볼 수 있습니다. 설계도를 잘 만들어놓으면 객체들도 쉽게 만들 수 있겠죠?

객체는 속성과 기능, 두 종류의 구성요소로 이루어져 있으며 각각의 속성과 기능은 객체의 멤버라고 합니다. **속성은 객체의 고유한 값**을 의미합니다. 스마트폰을 예로 들면 스마트폰의 가로, 세로, 배터리 용량 등 스마트폰의 스펙 하나하나가 스마트폰 객체의 속성이 될 것입니다. **기능은 말 그대로 해당 객체를 이용하여 수행할 수 있는 기능**들을 의미합니다. 스마트폰으로 계속 예를 들면 전화하기, 문자하기, 사진 찍기 등이 있겠군요.

특별히 객체지향에서는 **속성을 객체의 멤버변수(member variable)**, **기능을 객체의 메서드(method)**라고 부릅니다. 앞으로 속성과 기능 대신 사용할 용어들입니다. 프로그래밍 관점에서 이를 보면 멤버변수는 처리해야 할 데이터이고, 메서드는 데이터와 관련된 함수라고 볼 수 있습니다. 

그러면 간단한 예를 통하여 자바에서 객체를 사용하는 방법에 대하여 알아보겠습니다.

```java
class SmartPhone {
	// 스마트폰의 속성 (멤버 변수)
	int width;
	int height;
	int lens;
	...

	// 스마트폰의 기능 (메서드)
	void call();
	void sendMessage();
	void takePicture();
	void displayTime();
	...
}

// 클래스명 참조변수명 = new 클래스명();
// 스마트폰 객체 생성
SmartPhone s = new SmartPhone();   
```

자바에서는 앞의 배열을 생성할 때도 사용했던 new 연산자를 이용하여 **클래스명 변수병 = new 클래스명();** 형식으로 객체를 생성합니다. 그리고 원칙적으로 이 참조변수를 통해서만 해당 객체의 내부, 멤버 변수와 메서드에 접근할 수 있습니다.

```java
s.width;   // 스마트폰의 가로
s.call();  // 스마트폰으로 전화하기
```

5장에서 배열을 배웠듯 당연히 객체의 배열도 생성이 가능합니다. 객체들을 배열에 저장하여 관리하면 더 효율적이고 편리하게 관리할 수 있겠죠? 객체 역시 참조 변수이니까 배열의 각 공간에 저장되는 것은 각 객체의 주소일 것입니다. 물론, 객체를 생성해서 각 객체 배열의 요소에 저장해야하고요.

```java
// 크기가 5인 SmartPhone 배열 생성
SmartPhone[5] smArr = new SmartPhone[5];

// 각 객체 배열 초기화  
smArr[0] = new SmartPhone();
...
smArr[4] = new SmartPhone();
```

## 변수와 메서드

객체는 클래스에 의하여 생성되고, 클래스는 데이터와 함수, 멤버변수와 메서드의 결합이라고 앞에서 살펴보았습니다. 자바는 기본적으로 객체지향언어이기 때문에 다른 언어와 달리 모든 것이 클래스 안에서 정의되고 사용되어야 합니다. 이번에는 클래스 안에서 변수와 메서드가 어떻게 정의되는지 더 자세하게 살펴보겠습니다.

 

### 변수(variable)

C와 파이썬에는 변수에 지역 변수(local variable)와 전역 변수(global variable)이 있다는 것은 다들 아실거라 생각합니다. 하지만 자바는 모든 것이 클래스 내에서 정의되는지라 변수의 종류를 지역 변수와 전역 변수로 나누기에는 조금 어려움이 있습니다. 자바에는 **클래스 변수, 인스턴스 변수, 지역 변수**의 세 종류의 변수가 있습니다. 다음의 예를 보시죠. 제가 지금 이 글을 쓰고 있는 시각이 오후 2시 21분이어서 간단하게 스마트폰에서 시간을 띄우는 기능의 `displayTime()` 메서드를 정의하고 추가적으로 이 스마트폰이 팔린 개수를 담는 `numOfSoldPhones` 변수를 정의하여 앞에서 사용했던 `SmartPhone` 클래스를 조금 더 구체화해봤습니다. 

```java
class SmartPhone {
	// 스마트폰의 속성 (멤버 변수)
  // 인스턴스 변수
	int id;
	int storageInUse;        // 사용중인 저장공간
	String[] installedApps;  // 설치된 앱들

  // 클래스 변수
	static int width;
	static int height;
	static int lens;
	static int numOfSoldPhones;

	// 스마트폰의 기능 (메서드)
	void displayTime() {
		int hour = 14;
		int minute = 21;
		System.out.println("현재 시각은 "+ hour + "시 " + minute + "분 입니다.");
	}
}
```

위 예시에는 세 변수가 모두 정의되어 있습니다. 표로 먼저 보겠습니다.

| 변수의 종류 |  선언 위치 | 생성 시기 | 위 예시에서의 예 |
| --- | --- | --- | --- |
| 클래스 변수 | 클래스 영역 | 클래스가 메모리에 올라갈 때 | static int width; |
| 인스턴스 변수 | 클래스 영역 | 인스턴스가 생성되었을 때 | int storageInUse;
String[] installedApps; |
| 지역 변수 | 클래스 영역 이외의 영역 (메서드, 생성자 블럭 내부) | 변수 선언문이 수행되었을 때 | int hour = 14; |

지역 변수는 다른 언어에서 함수 내에서 선언되고 사용되는 변수를 말하듯, 자바에서도 유사하게 메서드 내에서 선언되고 사용되는 변수를 의미합니다. 따라서 이를 제외하고 클래스 변수와 인스턴스 변수에 대하여 살펴보겠습니다. 

`SmartPhone` 클래스를 이용하여 스마트폰이 만들어지면 사용자들에게 팔려 각 사용자들에 의해 사용이 됩니다. 사람들마다 각기 스마트폰을 사용하는 용도가 다르겠죠. 설치하는 앱들도 각자 다를 것입니다. 이렇게 **인스턴스마다 고유한 상태를 유지해야 하는 속성의 경우에 선언하는 변수가 인스턴스 변수(instance variable)**입니다. 인스턴스마다 독립적인 저장 공간을 가지므로 서로 다른 값을 저장할 수 있는 것이죠. 일반적인 변수 선언과 동일한 방법으로 클래스 내에서 선언하면 됩니다. 

또, 모든 스마트폰이 공유하는 공통된 속성도 있습니다. 스마트폰의 가로 길이나, 세로 길이 등은 모든 스마트폰에서 변하지 않는 속성이지요. 해당 기종의 스마트폰이 팔린 대수도 모든 스마트폰이 공유하는 공통된 속성일 것입니다. 이렇게 **모든 인스턴스가 공통적인 값을 유지해야 하는 경우 선언하는 변수가 클래스 변수(class variable)**입니다. 클래스가 메모리에 올라갈 때 클래스 변수를 저장하는 공간이 생성되며, **모든 인스턴스가 이 저장공간을 공유**함으로써 모든 인스턴스가 공통적인 값을 유지할 수 있습니다. 일반적인 변수 선언 앞에 `static`을 붙여서 선언하면 됩니다.

한가지 더 클래스 변수가 인스턴스 변수와 다른 점은 클래스 변수의 경우 인스턴스 생성 없이 클래스가 메모리에 올라가기만 하면 사용이 가능하다는 점입니다. `Math` 클래스의 `PI`가 이와 같은 클래스 변수입니다. 

### 메서드

자바에서의 메서드는 다른 언어에서의 함수와 동일합니다. 단지 자바가 객체지향언어 이기에 함수들이 모두 클래스 내부에서 정의되어 있어서 함수 대신 메서드라는 용어를 사용합니다. 메서드의 선언, 구현, 반환 등은 모두 함수의 선언, 구현, 반환 등과 같기 때문에 이들에 대한 내용은 생략하고 함수를 사용하는 이유, 메서드를 사용하는 이유에 대하여 한번 더 짚고 메서드로 넘기는 매개변수 대하여 알아보겠습니다.

- 높은 재사용성 (reusability)
- 중복된 코드의 제거
- 프로그램의 구조화

### 매개변수

메서드를 호출할 때 넘기는 변수가 바로 **매개변수(parameter)** 입니다. 변수의 종류가 기본형과 참조형으로 두 종류인 만큼, 매개변수 역시 기본형 매개변수와 참조형 매개변수가 있습니다. 기본형 변수가 값을 저장하고, 참조형 변수가 주소를 저장한다는 것을 고려했을 때, **기본형 매개변수는 메서드에 값이 넘어가는 것이고, 참조형 매개변수는 메서드에 해당 변수의 주소가 넘어가는 것**이겠죠. 그러면 값 자체만 넘어가면 변수는 무관해지는 것이기 때문에 변수의 값을 읽기만 할 수 있을 것입니다. 반대로 참조형 매개변수로 변수의 주소가 넘어가면 변수 자체를 넘기는 것과 동일한 효과를 지니기 때문에 변수의 값을 읽을 수 있을 뿐만 아니라 변수의 값을 변경할 수도 있습니다.

중요한 것은 자료형에는 두 가지 종류만 존재하며, 그 두 가지는 기본형과 참조형이고, 기본형은 값을, 참조형은 주소를 저장한다는 것이라고 생각합니다. 이를 기억하고 있으면 기본형 매개변수와 참조형 매개변수도 쉽게 이해할 수 있을 것이라 생각합니다. 

### 매개변수의 유효성 검사

메서드를 사용하는데 있어서 제일 중요한 것은 메서드로 넘어오는 **매개변수의 유효성 검사**라고 생각합니다. 메서드를 호출하는 쪽이 알아서 적합한 값을 넘기겠지라는 생각을 절대로 가져서는 안되고, 가능한 모든 경우의 수에 대하여 고민하고 그에 대한 모든 처리를 구현해야합니다. 그러한 코드들이 정교하고 섬세하게 구현된 코드라고 생각합니다. 

```java
// x / y
double divide(int x, int y) {
	if (y == 0) {    // 나누는 수가 0이면 안된다
		System.out.println("Unavailable!");
		return 0;
	}
	return x / (double)y;
}
```

### JVM의 메모리 구조

인스턴스를 생성하기 위해서는 일정 공간의 메모리 공간이 필요합니다. 메서드를 실행하는 경우에도 메모리 공간이 필요합니다. 이 메모리 공간에 대하여 잠시 살펴보겠습니다.  JVM의 메모리는 크게 3가지 영역으로 나뉩니다. 메서드 영역(method area), 힙(heap), 호출 스택(call stack)으로 나뉘며 각각의 역할은 다음과 같습니다. 

- 메서드 영역(method area): 클래스 파일을 읽어 해당 클래스에 대한 정보를 저장하는 공간. 클래스 데이터와 **클래스 변수**가 저장되는 공간.
- 힙(heap): 인스턴스가 생성되는 공간. 인스턴스 데이터와 **인스턴스 변수**들이 생성되는 공간
- 스택(stack): 메서드의 작업에 필요한 메모리 공간을 제공해주는 메모리 공간. 메서드가 작업을 수행하는 동안 **지역 변수**와 그 중간 결과등을 저장하는데 사용되며 메서드가 종료되면 할당되어 있던 메모리 공간도 자동으로 반환이 됨.

메서드에 필요한 메모리 공간은 스택에 쌓이게 됩니다. 그리고 메모리는 한정적이기 때문에 스택에 쌓을 수 있는 메서드의 수도 한정되어 있습니다. 이를 넘어가면 오류가 발생하겠죠. 그 오류가 바로 유명한 **스택 오버플로우(stack overflow)**입니다. 주로 재귀호출을 잘못 구현하여 발생하며, 대부분 재귀 탈출문을 작성하지 않아 또는 탈출문의 식이 유효하지 않아 발생합니다. 

### 클래스 메서드와 인스턴스 메서드

변수에 클래스 변수와 인스턴스 변수가 있는 것처럼 메서드에도 **클래스 메서드**와 인스턴스 메서드가 있습니다. 변클래스 변수와 동일하게 **모든 인스턴스에 공통으로 사용되는 메서드** 앞에 `static`을 붙여서 만들 수 있습니다. 주의할 점은 클래스 메서드는 인스턴스 변수를 사용할 수 없다는 것입니다. 클래스가 메모리에 올라가도 해당 클래스에 대한 인스턴스는 생성되지 않았을 수도 있기 때문에 사용할 수 없습니다. 즉, 쉽게 생각해서 클래스 메서드는 인스턴스 전체가 공통으로 유지해야 하는 클래스 변수를 다루는 메서드라고 생각하면 될 것 같습니다. 

클래스 메서드를 보여주는 좋은 예가 `Math` 클래스라고 생각합니다. 어떠한 수의 절댓값을 구할 때 우리는 `Math.abs()` 메서드를 이용합니다. 이때, 우리는 `Math` 인스터스의 생성 없이 클래스를 이용하여 바로 값을 구하죠. 이 `abs()`가 클래스 메서드입니다. 

```java
int num = Math.abs(num);
```

## 오버로딩 (overloading)

`Math.add(a, b)`를 사용하면 우리는 `a`와 `b`를 더한 값을 얻을 수 있습니다. 근데 `a`가 정수형이든 실수형이든 상관없이 `add()` 함수를 사용하여 값을 얻을 수 있습니다. 이렇게, **한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 오버로딩(overloading)**이라고 합니다. 메서드를 오버로딩 하기 위해서는 다음의 조건들을 만족해야합니다.

1. 메서드 이름이 같아야한다.
2. **매개변수의 개수 또는 타입**이 달라야 한다.

```java
class Math {
	
	static int add(int a, int b) {
		return a + b;
	}

	static double add(double a, double b) {
		return a + b;
	}
}
```

중요한 것은 매개변수의 개수 또는 타입이 달라야한다는 것입니다. 동일 이름의 메서드를 구분할 수 있는 방법은 매개변수 밖에 없기 떄문입니다. 그래야 컴파일러가 같은 이름의 메서드에 대하여 어떠한 메서드를 사용할지 알 수 있습니다. 

## 생성자 (Constructor)

Part 1의 마지막, 생성자입니다. 우리가 변수를 배울 때, 배열을 배울 때 초기화를 하는 방법에 대하여 배웠습니다. Part 1의 마지막으로 **인스턴스를 초기화하는 메서드인 생성자(Constructor)**에 대하여 알아보겠습니다.

생성자라고 거창하게 말하고 있지만 방금 전에 말했듯 생성자도 하나의 메서드입니다. 메서드이기에 매개변수들을 넘길 수 있으며, 사용자가 원하는 값으로 메서드를 초기화하고 싶을 때 생성자를 정의하고 그 생성자를 이용하여 객체를 생성하면 됩니다. 생성자를 정의할 때 조건은 다음과 같습니다.

1. 생성자의 이름은 클래스의 이름과 동일해야 합니다. 
2. 생성자는 리턴 값이 없습니다. 

모든 생성자는 반환 값이 없는 void 타입의 메서드이기 때문에 void를 생략하여 작성합니다. 

```java
class SmartPhone {
	int id;
	int storageInUse;        
	int totalStorage;
	ArrayList<String> installedApps;  

	SmartPhone() {}  // 각 변수들의 초기값으로 초기화가 이루어짐.
	SmartPhone(int i, int s, ArrayList<String> iA) {
		id = i;
		storageInUse = s;
		installedApps = iA;
	}
}
```

특정 부분만 자신이 원하는 값으로 초기화를 하고 나머지 부분은 기존의 생성자를 하드코딩하여 초기화를 할 수도 있습니다. 이 경우, 한 생성자에서 다른 생성자를 호출할 경우에는 `this()` 메서드를 사용합니다.

```java
SmartPhone(int t) {
	totalStorage = t;
	this();
}
```

스마트폰의 각 기종은 여러 종류의 저장 공간을 지원합니다. 처음 스마트폰을 생성할 때에는 나머지 모든 정보가 같고 저장 공간만 다르기 때문에 저장 공간의 크기만 우리가 원하는 값으로 초기화를 하고 나머지는 동일하게 초기화를 할 수 있습니다. 이때 위와 같이 `this()`를 사용하면 **코드를 보다 간결하고 직관적으로 작성할 수 있습니다.**

또, 매개변수의 이름과 인스턴스 변수의 이름을 동일하게 하여 초기화하는 경우가 있습니다. 아니, 저는 대부분 이렇게 초기화를 합니다. 이 경우에는 **인스턴스 자신을 나타내는 참조 변수인 `this`를 이용하여 인스턴스 멤버에 접근하여 초기화**를 합니다. 

```java
SmartPhone(int id, int storageInUse, ArrayList<String> installedApps) {
		this.id = id;
		this.storageInUse = storageInUse;
		this.installedApps = installedApps;
	}
```

`this`는 꽤나 유용하기 때문에 잘 사용하면 코드를 보다 직관적이고 깔끔하게 작성할 수 있습니다.

여기까지가 Part 1에 해당하는 부분입니다. 약간 상식적이라고 생각되는 부분들은 생략하면서도 중요한 부분들만 넣는다고 하였는데 글이 굉장히 길어진 것 같습니다. 그래도 여기에 있는 내용들이 객체지향의, 클래스의 기본이기 때문에 매우 중요합니다. 다음 시간에는 객체지향에 대하여 더 깊게 들어가보는 시간을 갖도록 하겠습니다. 감사합니다.