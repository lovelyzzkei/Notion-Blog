# 객체지향 프로그래밍(OOP) - Part 2

2022.07.08

Part 1에 이어서 자바의 객체지향 프로그래밍에 대하여 알아보겠습니다. Part 1에서는 객체(인스턴스)를 생성할 수 있는 방법인 클래스와 클래스를 구성하는 멤버인 속성과 기능, 멤버 변수와 메서드에 대하여 알아봤습니다. 이번 시간에는 여러 클래스들을 정의하고 클래스 간의 상호작용, 특히 클래스 간의 상속에 대하여 중점적으로 살펴보고, 객체지향 프로그래밍에 있어 조금 더 심화된 내용을 공부하도록 하겠습니다.

## 상속(inheritance)

Part 1에서 계속해서 예를 들었던 SmartPhone 클래스를 가지고 Part 2에서도 계속 확장하며 예를 들어보겠습니다. 간단한 예시를 위하여 Part 1에서 자세한 예시를 위하여 추가하였던 부분은 제거하였습니다.

```java
class SmartPhone {
	int id;
	
	void call() { /* 내용 생략*/ }
	void message() { /* 내용 생략*/ } 
}
```

우리가 평생 하나의 스마트폰만을 사용하지는 않습니다. 거의 1년마다 새로운 핸드폰이 출시되고 있고, 핸드폰을 오래 쓰는 사람도 2~3년 정도 쓰면 핸드폰을 바꿉니다. 새로운 스마트폰은 보통 이전의 스마트폰의 기능들을 모두 포함하고, 그 기능들에 여러 기능들이 추가되어 출시됩니다. 제가 쓰는 핸드폰이 아이폰이라 아이폰으로 예를 들어보겠습니다. 최근에 핸드폰을 아이폰8에서 아이폰13으로 바꿨는데요. 이 둘을 간단하게 클래스로 한번 작성해 보겠습니다.

```java
class IPhone8 {
	int id;
	int camera;
	int storage;
	boolean touchID;
	
	void call();
	void message();
}
```

```java
class IPhone13 {
	int id;
	int camera;
	int storage;
	boolean faceID;
	
	void call();
	void message();
}
```

간단하게 카메라, 고유 ID, 저장 용량들을 멤버 변수로 정의해봤습니다. 제가 아이폰8에서 아이폰13으로 바꾸면서 가장 편리하다고 생각하는 것이 바로 Face ID인데요. 예전 아이폰의 동그란 홈버튼도 좋았지만 요즘 아이폰의 큰 화면도 매우 좋은 것 같습니다. 

다시 코드로 돌아오면, 위 두 클래스의 차이는 `touchID`와 `faceID` 밖에 없습니다. 중복되는 부분이 너무 많다는 거죠. 코드에서 중복되는 부분이 많으면 가독성이 떨어지고 코드의 유연성도 떨어지게 됩니다. 그런데 생각해보면 `touchID`와 `faceID`를 제외한 나머지 멤버들은 모두 `SmartPhone` 클래스의 기본 멤버들입니다. 이를 확장해서 `IPhone8` 클래스와 `IPhone13` 클래스를 작성할 수 있지 않을까요? 이를 가능하게 해주는 것이 바로 **상속(inheritance)**입니다. 

**상속(inheritance)은 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 기법이며, 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 큰 도움을 주는 기법**입니다. 상속을 하는 클래스를 조상 클래스, 부모 클래스 라고 하며, 상속을 받는 클래스를 자손 클래스, 자식 클래스라고 합니다. 위의 아이폰 예시를 상속을 이용하여 작성하면 다음과 같이 작성할 수 있습니다.

 

```java
class SmartPhone {
	int id;
	int camera;
	int storage;
	
	void call() { /* 내용 생략*/ }
	void message() { /* 내용 생략*/ } 
}

// SmartPhone 클래스에서 확장한 IPhone8
class IPhone8 extends SmartPhone {
	boolean touchID;
}

// SmartPhone 클래스에서 확장한 IPhone13
class IPhone13 extends SmartPhone {
	boolean faceID;
}
```

`extends` 키워드를 사용하여 클래스 간의 상속을 구현할 수 있으며, 위의 예시에서 부모 클래스는 `SmartPhone`, 자식 클래스는 `IPhone8`, `IPhone13` 입니다. 상속을 받으면 부모 클래스의 모든 멤버를 상속받기 때문에 추가적인 멤버들만 자식 클래스에 구현해주면 됩니다. 중복이 제거되어 훨씬 보기 편하고 관리가 쉬워졌죠.

중복을 줄일수록 관리가 쉬운 이유는 간단합니다. 중복이 많을수록 그 중복되는 부분을 일일히 모두 관리를 해주어야하고, 중복을 없앨수록 공통된 부분만 관리를 해주면 되기 때문이죠. 위의 예시에서도 `SmartPhone` 클래스의 멤버들을 관리해주면 그 내용들이 자동적으로 `IPhone8`과 `IPhone13` 클래스에 적용이 됩니다.

상속은 객체지향의 핵심이라고 생각합니다. 세상의 많은 객체들이 공통 부분들을 가지고 있기 때문에 상속은 더 빛을 발하며 이후에 나올 여러 기능들, 특히 다형성(Polymorphism)에 있어서 상속은 매우 중요합니다.

## 포함(Composite)

클래스 간의 관계를 표현하는 또 하나의 방법은 **포함(Composite)**입니다. 메서드의 기본 원칙은 하나의 메서드는 하나의 기능만을 수행해야한다는 것입니다. 하나의 메서드가 둘 이상의 기능을 수행하면 그 기능을 분리하여 새로운 메서드로 만드는 것이 보기에도 좋고 이해하기가 쉽죠. 클래스도 마찬가지입니다. **하나의 클래스는 하나의 객체만을 설명하는 것이 좋습니다.** 하나의 객체가 이 객체도 설명하고, 저 객체도 설명하여 거대해진다면 해당 클래스를 사용하는 사용자 입장에서 혼란이 생길 수 있습니다. 위의 예시를 가지고 설명을 해보죠.

위의 예시에서 멤버 변수중 camera를 int형으로 선언하였지만 사실 카메라 자체도 많은 속성과 기능을 가지고 있죠. 렌즈의 개수, 렌즈의 특성, 다양한 카메라 기능들 등 카메라도 하나의 클래스로 표현이 가능합니다. 

```java
class Camera {
	int aperture;  // 조리개

	// 인물 사진
	void portrait() {
		...
	}
}
```

```java
class SmartPhone {
	int id;
	Camera camera;
	int storage;
	
	void call() { /* 내용 생략*/ }
	void message() { /* 내용 생략*/ } 
}

// SmartPhone 클래스에서 확장한 IPhone8
class IPhone8 extends SmartPhone {
	boolean touchID;
}

// SmartPhone 클래스에서 확장한 IPhone13
class IPhone13 extends SmartPhone {
	boolean faceID;
}
```

위의 예시는 포함과 상속이 모두 사용된 코드 예시입니다. 절대적인 방법은 아니지만 ‘~은 ~이다’로 설명이 된다면 상속을, ‘~은 ~을 가지고 있다’로 설명이 되면 포함 관계를 맺어주면 더 유기적인 코드를 작성할 수 있다.

참고로, **모든 클래스의 조상에는 Object 클래스가 존재**합니다. 클래스가 상속받는 클래스가 없다면 컴파일러가 자동으로 Object 클래스를 상속받게 하며, Object 클래스에는 모든 인스턴스가 가져야 할 기본적인 11개의 메서드가 정의되어 있습니다. 각각의 클래스에서 이 메서드를 자신에게 맞게 변경하여 사용하며, 이를 오버라이딩(overriding)이라고 합니다. 바로 이어서 오버라이딩에 대하여 알아보겠습니다.

## 오버라이딩(overriding)

**오버라이딩(overriding)은 조상 클래스로부터 상속받은 메서드의 내용을 자신에 맞게 변경하는 것을 의미합니다.** 역시 예시를 들어보죠.

```java
class Point {
	int x;
	int y;
	
	String getLocation() {
		return x + " " + y;
	}
}
```

```java
class Point3D extends Point {
	int z;

	String getLocation() {
		return x + " " + y + " " + z;
	}
}
```

2차원 좌표의 점을 나타내는 `Point` 클래스와 이를 확장한 3차원 좌표의 점을 나타내는 `Point3D` 클래스를 정의하였습니다. `Point`와 `Point3D`의 `getLocation()` 메서드는 모두 자신의 좌표를 출력해야하지만 `Point3D`의 경우 `Point` 클래스의 메서드를 그대로 사용할 경우 `x`와 `y`값만 출력이 됩니다. 따라서 이 메서드를 `Point3D`에 맞게 변경해주어야 합니다. 이와 같이 **조상 클래스와 동일한 의미를 지니지만 내용은 다른 경우 새로운 메서드를 추가하는 대신 기존의 메서드를 변경하는 것을 오버라이딩**이라고 합니다. 당연히 새로운 메서드를 추가하는 것보다 더 직관적이겠죠?  

오버로딩과 이름이 비슷하지만 전혀 다른 기법임을 인지하시기 바랍니다. **오버로딩은 새로운 메서드를 정의**하는 반면, **오버라이딩은 기존의 메서드를 재정의하는 것**입니다. 그렇기 때문에 오버로딩과 달리 오버라이딩하는 메서드는 조상 클래스의 메서드와

- **이름**이 같아야 하고
- **매개변수**가 같아야 하며
- **반환 타입**이 같아야 합니다.

### super과 super()

Part 1에서 인스턴스 자기 자신을 참조하는 변수인 `this`와 자기 자신을 초기화하는 생성자인 `this()`에 대하여 알아봤습니다. 상속을 받은 클래스의 경우 `this`, `this()` 뿐만 아니라 조상 클래스를 참조할 수 있는 `super`와 `super()`이 있습니다. `super`를 이용하여 조상의 멤버들을 참조할 수 있기 때문에 메서드 오버라이딩을 할 때 기존의 조상 메서드에 기능을 추가하는 형태로 메서드를 재정의 한다면 조금 더 간편하게 구현할 수 있습니다.   

```java
class Point3D extends Point {
	int z;

	String getLocation() {
		return x + " " + y + " " + z;
	}
}
```

```java
class Point3D extends Point {
	int z;

	String getLocation() {
		return super.getLocation() + " " + z;
	}
}
```

`super()`은 조상 클래스의 생성자를 호출하는데 사용됩니다. 자손 클래스를 이용하여 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 모두 포함된 인스턴스가 생성됩니다. 이때 주의할 점은 **자손 클래스의 생성자 첫번째 줄에서 조상 클래스의 멤버들을 초기화, 즉 조상 클래스의 생성자가 호출되어야 한다는 것**입니다. 자손 클래스의 메서드가 조상 클래스의 멤버들을 사용할 수 있기 때문에 자손 클래스의 멤버들보다 먼저 초기화가 되어야 합니다. 이때 사용하는 생성자가 바로 `super()`입니다. 자손 클래스의 생성자에 조상 클래스 멤버들의 초기화에 대한 별다른 지시가 없으면 컴파일러가 자동으로 `super()`를 추가하며, 사용법은 `this()`와 동일합니다. **핵심은 조상 클래스의 멤버변수는 조상의 생성자에 의해 초기화되어야 한다는 것입니다.** 

다음은 super와 super()를 이용하여 Point3D를 재구현한 코드입니다. 

```java
class Point {
	int x;
	int y;

	Point(int x, int y) {
		this.x = x;
		this.y = y;
	}

	String getLocation() {
		return x + " " + y;
	}
}
```

```java
class Point3D extends Point {
	int z;

	Point3D(int x, int y, int z) {
		super(x, y);
		this.z = z;
	}

	String getLocation() {
		return super.getLocation() + " " + z;
	}
} 
```

## 제어자(modifier)

자바 코드를 작성하다보면 `public` 이라든지 `static` 처럼 멤버 앞에 이것저것 붙는 단어들이 있습니다. 자바에서는 이들을 **제어자(modifier)라고 하며 변수나 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여**해줍니다. 이번에는 이들 중 많이 사용되는 것들에 대하여 알아보겠습니다.

### 접근 제어자

먼저 **접근 제어자는 클래스 외부에서 클래스의 멤버들에 접근을 제어해주는 제어자**입니다. 이들은 객체지향의 개념 중 하나인 **캡슐화(encapsulation)**를 구현시켜주는 제어자입니다. 각 객체에는 유지해야하고 보호해야하는 데이터들이 존재합니다. 만약 객체가 사람이라면 주민번호 등 개인정보들이, 객체가 핸드폰이라면 비밀번호 등이 이러한 데이터들에 해당되겠죠. 이러한 데이터들은 외부에서 접근이 가능하면 안됩니다. 특정 방법을 통해서 특정 사용자만 접근이 가능해야겠죠. **접근 제어자는 이렇듯 외부로부터 데이터를 보호하고, 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해 사용**합니다. 접근 제어자에는 다음의 4가지 종류가 있습니다.

- `public`: 접근 제한이 없음.
- `protected`: 같은 패키지 내에서 + 다른 패키지의 자손 클래스에서 접근 가능
- `default`: 같은 패키지 내에서만 접근 가능.
- `private`: 같은 클래스 내에서만 접근 가능.

우리가 흔히 쓰는 `public`은 접근 제한이 없는 접근 제어자입니다. 그래서 우리가 자바 코드를 작성할 때 `main` 함수에는 항상 `public`을 붙이죠. 또, 위에서 말한 중요 데이터들은 `private`을 쓰는 것이 좋을 것 같습니다. 그래야 외부에서 직접 접근이 불가능하죠. 그래서 보통 `private`로 저장하는 데이터들에는 **데이터를 읽어오는 겟터(getter) 메서드와 데이터를 세팅하는 셋터(setter) 메서드**를 같이 구현해줍니다. 겟터는 데이터 읽기만 가능하고, 셋터 메서드에는 여러 조건을 걸어 유효한 데이터만 저장이 가능하도록 하는 것이 일반적입니다.

```java
public class SmartPhone {
	private String pw;
	
	public String getPW() { return pw; }
	public void setPW(String newPw) {
		if (newPW.length() < 8) 
			return false;
		return true;
	}
}
```

### 그 외 제어자

접근 제어자 외에도 여러 제어자들이 있습니다. 그 중에서 가장 많이 사용되는 세 가지 제어자는 다음과 같습니다.

- `static`: ‘클래스의’, ‘공통적인’. 모든 인스턴스에 공통적인 멤버를 만들 때 붙이는 제어자.
- `final`: ‘마지막의’, ‘변경될 수 없는’. 변경되지 않을 값인 상수를 만들 때 붙이는 제어자.
- `abstract`: ‘추상의’, ‘미완성의’. 추상 클래스와 추상 메서드를 선언할 때 붙이는 제어자.

static과 final에 대해서는 언급한 적이 있지만 abstract는 처음 보는 것 같습니다. 이에 대해서는 잠시 뒤에 더 자세하게 알아보겠습니다.

## 다형성(Polymorphism)

아이폰은 스마트폰입니다. 하지만 모든 스마트폰은 아이폰이 아닙니다. 스마트폰에는 갤럭시도 있고, 다른 종류의 아이폰들도 있기 때문이죠. 그렇기 때문에 아이폰은 아이폰이라 말할 수도 있지만 더 큰 개념인 스마트폰이라고도 말할 수 있습니다. 이처럼 **하나의 객체가 여러 가지 형태를 가질 수 있는 능력을 객체지향개념에서 다형성(Polymorphism)**이라고 말합니다. 조금 더 구체적으로 이야기하면 **조상 클래스의 참조변수로 자손 클래스의 인스턴스를 참조할 수 있게 하는 것이 다형성**입니다.

```java
class SmartPhone {
	int id;
	int price;
	int storage;
	Camera camera;
	
	void call() { /* 내용 생략*/ }
	void message() { /* 내용 생략*/ } 
}

// SmartPhone 클래스에서 확장한 IPhone8
class IPhone8 extends SmartPhone {
	boolean touchID;
}

// SmartPhone 클래스에서 확장한 IPhone13
class IPhone13 extends SmartPhone {
	boolean faceID;
}
```

 앞에서 사용했던 스마트폰의 예제를 다시 가져왔습니다. 여기서 `IPhone8`과 `IPhone13`이 `SmartPhone`의 자손이기 때문에 다형성을 통하여 다음의 코드가 가능하다는 것입니다.

```java
SmartPhone i8 = new IPhone8();
SmartPhone i13 = new IPhone13();
IPhone8 i8 = new SmartPhone();  // 에러!
```

이렇게 인스턴스를 생성할 경우 `i8`과 `i13`은 모두 타입이 `SmartPhone`입니다. 하지만 반대는 불가능하죠. 모든 스마트폰은 아이폰이 아니기 때문입니다. 이 얘기는 다른 말로 하면 `i8`과 `i13`으로는 `SmartPhone`의 멤버만 접근이 가능하다는 것입니다. **즉, 조상 클래스의 멤버만 접근이 가능합니다.** 하지만 자손 클래스의 타입에는 조상 클래스에 없는 멤버가 있을 수 있기 때문에 그 반대는 불가능하다는 것이죠.

그러면 그냥 `IPhone8`이랑 `IPhone13` 타입으로 선언하면 되는 것을 왜 굳이 `SmartPhone` 타입으로 선언해서 오히려 더 적은 멤버에만 접근이 가능하도록 제한을 두는 것일까요?? 이에 대해 제가 내린 결론은 **‘중복을 제거하기 위해서’** 입니다. 

`SmartPhone` 클래스에 스마트폰의 가격을 나타내는 `price`라는 멤버 변수를 추가하고 스마트폰을 사는 사람을 나타내는 `Buyer`라는 클래스를 만들어 스마트폰을 구입하는 것을 구현해보겠습니다.

```java
class Buyer {
	int budget;

	void buy(IPhone8 i8) {
		budget -= i8.price;
	}

	void buy(IPhone13 i13) {
		budget -= i13.price;
	}
}
```

고객이 어떤 핸드폰을 살지 모르니 각 스마트폰 종류마다 `buy()` 메서드를 구현해주어야 합니다. 하지만 두 코드를 보면 두 아이폰의 가격만 다를 뿐 실제 기능은 동일합니다. 그리고 그 가격은 두 아이폰의 공통 조상인 `SmartPhone`에서 상속된 멤버이죠. 그러면 다형성을 이용하여 두 코드를 다음과 같이 간단하게 할 수 있습니다.

```java
void buy(SmartPhone sm) {
	budget -= sm.price;
}
```

이렇게 구현하면 **새로운 스마트폰이 만들어져도 새로운 `buy()` 메서드를 구현하지 않아도 되고 중복되는 코드 또한 대폭으로 줄일 수 있기 때문에 더 유연하고 효율적인 코드가 만들어집니다.** 즉, 새로운 타입의 자손 클래스가 만들어지더라도 코드의 수정을 할 필요가 없다는 것입니다.

클래스 간의 상속 관계를 지정하고 메서드를 구현할 때 다형성을 고민하면서 메서드 및 다른 클래스들을 만들면 훨씬 더 효율적인 코드의 작성이 가능해집니다. 가독성 역시 올라가고요. 이후에 배울 내용들에 다형성을 잊지 말고 가져가다보면 자바의 객체지향을 좀 더 깊게 이해할 수 있을 것이라 생각됩니다.

## 추상 클래스(abstract class)

앞에서 제어자를 알아볼 때 `abstract`라는 제어자에 대하여 간단하게 언급했었습니다. 여기서는 이 `abstract`가 무슨 의미를 지니는 제어자인지 그 용도에 대하여 자세하게 살펴보겠습니다.

먼저 추상의 사전적 의미는 다음과 같습니다.

<aside>
💡 *낱낱의 구체적 표상이나 개념에서 **공통된 성질을 뽑아 이를 일반적인 개념으로 파악하는 정신 작용***

</aside>

여기에 객체지향의 개념을 넣어서 객체지향에서의 추상의 의미를 다시 적으면 다음과 같을 것입니다.

<aside>
💡 ***자손 클래스들에서 공통된 메서드를 뽑아 이를 조상 클래스로 만드는 작업***

</aside>

스마트폰의 예시를 가져와 조금 더 구체화해보죠. 

```java
class SmartPhone {
	... 
}

// SmartPhone 클래스에서 확장한 IPhone8
class IPhone8 extends SmartPhone {
	int touchID;

	boolean unlock(int touchID) {
		return touchID == this.touchID;
	}
}

// SmartPhone 클래스에서 확장한 IPhone13
class IPhone13 extends SmartPhone {
	int faceID;

	boolean unlock(int faceID) {
		return faceID == this.faceID;
	}
}
```

두 스마트폰 모두 잠금해제 기능이 있습니다. 아이폰 8의 경우는 touch ID를 이용하여, 아이폰 13의 경우에는 face ID를 이용하여 잠금을 해제할 수 있죠. 두 값 모두 스마트폰 내부에서는 어떠한 값으로 변경되어 저장될 것이기 때문에 임의적으로 타입을 int로 바꾸고 외부에서 들어오는 값과 비교하여 잠금을 해제하는 메서드인 `unlock()`를 구현하였습니다.

근데 이렇게 구현을 해놓고 생각을 해보니 잠금기능이 없는 스마트폰은 없습니다. 각자 잠금을 하는 방법이 다를 뿐 모든 스마트폰에는 잠금 기능이 있고, 이를 해제하는 기능도 존재하죠. 잠금과 해제는 스마트폰의 공통된 기능인 것입니다. 그러면 **조금 더 객체지향스럽게 코드를 작성하기 위해 이 기능을 추출하여 명시를 해주면 좋지 않을까요?** 이때 사용하는 것이 바로 추상 클래스 및 추상 메서드입니다. 

```java
abstract class SmartPhone {
	abstract boolean unlock(int pw);
	...
}

class IPhone8 extends SmartPhone {
	int touchID;
	boolean unlock(int touchID) { return this.touchID == touchID; }
	...
}

class IPhone13 extends SmartPhone {
	int faceID;
	boolean unlock(int faceID) { return this.faceID == faceID; }
	...
}
```

추상 클래스는 자손 클래스에 사용되는 여러 추상 메서드를 담고 있는 **미완성 설계도**입니다. 그 자체로 인스턴스의 생성이 불가능하고 상속을 통하여 자손 클래스에서 해당 메서드들을 구체화 해주어야 비로소 사용이 가능해집니다. 즉, 추상 클래스 자체로는 클래스로서의 역할을 못하지만, **새로운 클래스를 작성하는데 있어서 바탕이 되는 조상 클래스로서 중요한 의미를 갖습니다.** 새로운 클래스를 작성해야할 때 이를 바탕으로 작성하면 공통 부분을 빼먹지 않고 구현할 수 있어서 더 효율적으로 구현이 가능해집니다. 

근데 위의 코드를 보면 `abstract`가 달린 클래스와 메서드가 생겼을 뿐 자손 클래스의 부분에서 달라진 것은 없습니다(다형성을 이용하여 `SmartPhone` 클래스로 뺄 수도 있겠지만 지금은 추상 클래스를 설명하기 위한 특별한 예제라고 생각해주시면 감사하겠습니다.). 그럼에도 이를 **추상 메서드로 선언하는 이유는 자손 클래스에서 해당 메서드의 구현을 강제하기 위해서 입니다**. 자손 클래스에서 공통 부분을 빼먹고 구현하지 않을 수도 있기 때문에 이를 막기 위하여 추상 클래스 및 추상 메서드를 사용합니다.