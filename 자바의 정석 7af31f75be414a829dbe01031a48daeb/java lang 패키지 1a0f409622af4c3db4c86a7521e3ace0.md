# java.lang 패키지

2022.07.09

어느덧 자바의 정석 1권의 마지막 챕터입니다. 지금까지 우리는 프로그래밍에 있어서 정말 기본적인 변수, 연산자, 배열 등을 공부하였고, 자바가 어떻게 객체지향 개념을 구현하고 있는지에 대해서도 살펴보았습니다. 자바의 정석 1권의 마지막으로 자바를 이용한 프로그래밍에 있어서 가장 기본적인 클래스들을 담고 있는 `java.lang` 패키지에 있는 여러 클래스들 중에서 자주 사용되는 몇 가지 클래스에 대하여 알아보고 1권을 마무리하고자 합니다.

## Object 클래스

상속을 공부하면서 모든 클래스의 조상에는 Object 클래스가 있다고 배웠었습니다. 그리고 당시 Object 클래스를 배우면서 모든 인스턴스가 가져야 할 11개의 기본적인 메서드가 정의되어 있다고 말했었죠. 그 중 가장 많이 사용하는 2개의 메서드에 대해 알아보겠습니다.

### equals(Object obj)

`equals()`는 말 그대로 두 인스턴스가 같은가의 여부를 반환하는 메서드입니다. 하지만 한 가지 주의해야 될 점은 그 같은가의 여부를 참조변수의 값으로 판단한다는 것입니다. `Object` 클래스에 구현되어있는 `equals()`의 코드는 다음과 같습니다.

```java
public boolean equals(Object obj) {
	return (this == obj)
}
```

기본형 이외의 모든 변수는 참조형 변수이며 해당 데이터가 저장되어 있는 주소값을 가지고 있다고 하였습니다. 따라서 위의 `**equals()`는 주소값을 비교하여 동일 인스턴스인지의 여부를 반환하는 메서드**입니다. 우리의 직관과는 조금 다르죠. 우리가 보통 `equals()`를 호출하는 경우는 두 인스턴스의 값이 같은지의 여부를 원할 때일 것입니다. 따라서, 우리가 원하는 형태로 `equals()`를 사용하려면 오버라이딩이 필요합니다. 

### toString()

`**toString()`은 인스턴스에 대한 정보를 문자열로 제공할 목적으로 정의된 메서드**입니다. 새로운 객체에 대하여 `toString()` 메서드를 오버라이딩 해두면 디버깅도 쉽고, 해당 인스턴스가 저장하고 있는 값들을 더 편리하게 확인할 수 있습니다. 

## String 클래스

이전에 배열을 배우면서 `String` 클래스에 대하여 언급한 적이 있습니다. 자바에서는 `char[]` 에다가 여러 기능을 추가한 `String` 클래스를 통해 문자열을 지원한다고 배웠었습니다. 프로그래밍을 하면서 문자열은 빼놓을 수 없는 데이터이기 때문에 이번에 조금 더 자세히 보고자 합**니다.**

`**String` 클래스에서 중요한 점은 `String` 클래스도 문자열의 저장은 `char[]` 배열에 한다는 것**입니다. 5장에서 이를 언급하며 `String` 클래스와 `char[]` 사이의 변환이 자유롭다고 배웠었는데요. 그 이유가 바로 `String`이 문자열을 저장하는 기본형이 바로 `char[]` 이기 때문입니다. `String` 클래스는 여기에 여러 기능들이 추가된 클래스인 것이죠.

```java
public final class String implements java.io.Serializable, Comparable {
	private char[] value;    // 내부적으로 char[]에 문자열을 저장
	...
}
```

그래서 `String` 인스턴스는 한번 정의하면 그 값을 바꿀 수 없습니다. 배열의 크기가 고정적인 것과 연결지어 생각하면 쉽게 이해가 될 것이라 생각합니다. 문자열 간의 결합이나 추출 등 문자열 저장 이외의 문자열을 다루는 작업이 많이 필요한 경우 `String` 클래스 대신 `StringBuffer` 클래스를 사용하는 것이 더 효율적입니다.

String 클래스에는 equals() 메서드가 오버라이딩 되어있기 떄문에 문자열의 값 비교를 원한다면 equals()를 사용하면 된다. 문자열로 할 수 있는 작업이 많은 만큼 자바의 String 클래스에서도 많은 메서드를 지원하고 있습니다. 이들은 필요할 때 찾아서 쓰다 보면 자연스럽게 손에 익숙해지기 떄문에 이들에 대한 설명은 생략하도록 하겠습니다.

### StringBuffer, StringBuilder 클래스

이야기가 나온 김에 간단하게 `StringBuffer` 클래스에 대하여 알아보겠습니다. `StringBuffer` 클래스도 `String` 클래스와 동일하게 내부적으로는 `char[]` 에 문자열을 저장하지만 문자열을 편집할 수 있는 버퍼(buffer)를 가지고 있습니다. 쉽게 이야기하면 저장할 문자열의 길이보다 더 크게 문자열 배열을 생성하여 문자열을 저장하고 문자열 편집을 가능하게 해준다는 것입니다. 만일 버퍼의 크기가 문자열의 길이보다 작을 경우 버퍼를 크게해주는 작업이 필요하며 이는 더 큰 배열에 복사를 해주는 것과 동일한 작업이기 떄문에 비용이 많이 드는 작업입니다. 따라서 처음에 버퍼의 크기를 넉넉하게 잡아주는 것이 중요합니다. StringBuffer에도 여러 메서드가 있지만 이에 대한 내용은 생략하도록 하겠습니다.

```java
StringBuffer sb = new StringBuffer("abc");   // StringBuffer 인스턴스 생성
sb.append("123");   // abc123
```

`StringBuilder`는 `StringBuffer`와 동일하지만 스레드의 동기화를 빼 멀티 스레드가 아닌 프로그램에서 성능을 조금 더 높일 수 있는 클래스입니다.

## Math 클래스

자바에서는 여러 수학 연산들에 유용한 메서드들을 Math 클래스를 통하여 지원하고 있습니다. 기본적인 사칙연산은 물론이고 제곱, 제곱근, 로그, 지수, 삼각함수 등 일반적으로 수학에서 사용하는 많은 함수들이 메서드로 구현되어 있습니다. 이들에 대한 내용은 다른 언어에서와 유사하고 어느 정도 직관과 일치하기 떄문에 생략하도록 하겠습니다.

## 래퍼 클래스(Wrapper Class)

객체지향 개념에서 모든 것은 객체로 다루어져야 합니다. 하지만 우리가 배운 것들 중에 객체가 아닌 것들이 있었습니다. 바로 8개의 기본형(primitive type)들이었죠. 이 점 때문에 자바는 높은 성능을 얻었지만 완전한 객체지향 언어가 아니라는 얘기를 듣습니다.

하지만, 때로는 기본형들도 객체로 다루어져야 할 때가 있습니다. 어쩃든 자바의 대부분은 객체로 이루어져 있기 때문에 이들에 맞추기 위하여 기본형들도 객체로 변환하여 다뤄야할 때가 있습니다. **이때 기본형을 객체로 다루게 해주는 클래스가 래퍼 클래스(Wrapper Class)**입니다. 기본형이 참조형이 되었을 뿐 나머지는 동일합니다. **기본형을 래퍼 클래스로 감싸는 것을 오토박싱(auto-boxing)**, **래퍼 클래스를 기본형으로 변환하는 것을 언박싱(unboxing)**이라고 합니다. 이름에서도 알 수 있듯이 래퍼 클래스는 알맹이인 기본형을 감싸는 하나의 박스입니다. 

```java
int i = 10;
Integer wrapi = (Integer)i;  // 오토박싱: 기본형 -> 참조형
int unbox = wrapi;           // 언박싱: 참조형 -> 기본형
```

자바에서 이 래퍼 클래스의 개념은 간단하지만 꽤 중요하다고 저는 생각합니다. 제가 처음에 자바를 접했을 때 아무것도 모르는 상태에서 정수형을 나타내는 것이 int와 Integer 두개가 있는 것을 보고 이 둘의 차이점이 도대체 뭐지 하면서 1시간 정도 구글링을 했던 것이 기억이 나네요.

래퍼 클래스를 마지막으로 자바의 정석 1권 정리를 마무리하도록 하겠습니다. 래퍼 클래스 뒤에 조금 더 여러 클래스들에 대한 설명이 있지만 일일히 정리할 정도로 중요하다고 생각하지는 않습니다. 나중에 실무나 프로그래밍을 하면서 필요한 경우 정리를 추가하도록 하겠습니다.

그러면 2권에서 뵙겠습니다.