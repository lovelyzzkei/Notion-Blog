# 컬렉션 프레임워크(Collections framework)

2022.07.11

우리는 1권에서 여러 데이터를 관리하는 방법으로 배열을 배웠었습니다. 배열의 정의를 다시 보면 다음과 같습니다.

<aside>
💡 ***배열은 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것.***

</aside>

배열은 데이터들을 관리할 수 있는 가장 간단한 방법입니다. 쉽고 빠른 관리가 가능하죠. 하지만 배열은 크기가 고정적이고 값을 삭제하는 데에도 많은 비용이 듭니다. 실생활의 여러 상황들에 대처하기에는 배열은 조금 유연성이 떨어집니다. 

그래서 똑똑한 사람들이 데이터를 더 효율적으로 저장하고 관리할 수 있는 방법을 생각하고 만들다보니 자료구조(Data Structure)라는 개념이 생겼습니다. 컴퓨터과학에서 가장 중요한 개념이죠. 주어진 상황에 적합한 자료구조만 찾아 저장을 하여도 문제가 쉽게 풀리는 경우가 많습니다.

**컬렉션 프레임워크(Collections framework)는 자바에서 자료구조를 객체지향적으로 설계해놓은 것**을 의미합니다. 책에서 말하는 컬렉션 프레임워크의 정의는 다음과 같습니다.

<aside>
💡 ***컬렉션 프레임워크는 ‘데이터 군(群)을 저장하는 클래스들을 표준화한 설계’를 뜻한다.***

</aside>

**컬렉션(Collection)은 다수의 데이터, 데이터 그룹**을 의미하고, **프레임워크(Framework)는 표준화된 프로그래밍 방식**, 일관된 틀을 의미합니다. 컬렉션 프레임워크에 있는 모든 컬렉션 클래스들은 표준화된 방식, 일관된 방식으로 다룰 수 있도록 설계가 되어있기 때문에 사용법을 익히기가 쉽고, 이는 객체지향적으로 설계가 되어있기 때문에 코드의 재사용성이 높을 뿐더러 자바의 객체지향을 더 깊게 이해할 수 있습니다.

컬렉션 프레임워크에서는 컬렉션, 데이터 그룹에 크게 3가지 타입이 있다고 인식하고 각 컬렉션을 다루는데 필요한 기능을 가진 3개의 인터페이스를 정의하였습니다. 쉽게 이야기하여 **자바는 이 세상에 있는 정말 많은 데이터의 종류를 3가지로 나누어 각 데이터를 효율적으로 저장할 수 있는 인터페이스를 정의해 놓았습니다.**

| 인터페이스 | 컬렉션의 특징 | 중복여부 |
| --- | --- | --- |
| List | 순서가 있는 데이터의 집합 | 허용 |
| Set | 순서를 유지하지 않는 데이터의 집합 | 불허 |
| Map | 키(key)와 값(value)의 쌍으로 이루어진 데이터의 집합 | 키(key)는 불허, 값(value)은 허용 |

또, List와 Set의 컬렉션 클래스들에는 많은 공통부분이 있어서 이들을 다시 뽑아 Collection 인터페이스에 정의해 놓았습니다. 여기에는 데이터의 추가와 삭제 등 정말 기본적인 메서드들이 정의되어 있습니다. 그러면 각 인터페이스에는 어떠한 컬렉션 클래스들이 구현되어 있는지 알아보겠습니다.

## List

<aside>
💡 ***순서가 있는 데이터의 집합. 중복을 허용하는 데이터의 집합***

</aside>

### ArrayList

먼저, 가장 많이 사용되는 컬렉션 클래스인 `ArrayList`입니다. ArrayList는 C++의 Vector와 동일한 컬렉션 클래스이며 자바에도 `Vector`가 있었지만 컬렉션 프레임워크가 등장하면서 `Vector`를 개선한 것이 바로 `ArrayList`입니다.

**`ArrayList`는 `Object` 배열을 이용하여 데이터를 순차적으로 저장합니다.** 저는 이 부분이 `ArrayList`의 핵심이라고 생각합니다. 데이터의 추가와 삭제, 접근, 정렬 등 많은 기능을 지원하지만 결국에 이것들은 모두 배열을 가지고 다룬다는 것이죠. 

배열은 위에서 말했지만 크기가 고정입니다. 데이터를 `ArrayList` 에 추가할 때 배열에 저장할 공간이 없으면 더 큰 배열을 만들어 복사하고 추가합니다. 만약에 `ArrayList` 중간에 데이터를 추가하고 싶으면 해당 위치부터 모든 데이터들을 뒤로 한칸씩 민 뒤에 새로운 데이터를 저장해야합니다. 

데이터를 `ArrayList`에서 삭제할 때는 해당 데이터를 찾아 그 데이터부터 마지막 데이터까지 한칸씩 당겨서 저장을 하고 마지막 데이터를 `Null` 처리를 합니다. 배열을 사용하면 위의 작업들을 모두 해주어야 하지만 `ArrayList`에는 이 기능들이 모두 구현이 되어있다는 것입니다. 

이러한 이야기를 하는 이유는 결국 성능과 연결됩니다. `ArrayList`에서 데이터에 접근하는 것은 굉장히 빠릅니다. 인덱스로 접근하면 되기 때문이죠. 하지만 데이터를 추가하거나 삭제하는 것은 느립니다. 위에서 말한 많은 연산들을 수행해야 하기 때문이죠. 물론 순차적인 데이터의 추가와 삭제는 빠르게 수행이 가능합니다. 

즉, `**ArrayList`는 배열을 확장한 자료구조라고 말할 수 있으며 순차적인 데이터를 저장하는데 정말 적합한 컬렉션 클래스**입니다. 그러면 `ArrayList`의 단점을 보완한 컬렉션 클래스도 있지 않을까요?

### LinkedList

ArrayList가 순차적인 데이터들을 저장하기 위한 자료구조라면 LinkedList는 비순차적인 데이터를 저장하기 위한 자료구조입니다. **LinkedList의 각 데이터는 요소(node)로 이루어져 있으며 각 요소에는 자신의 데이터와 다음 요소의 주소값이 저장되어 있습니다.** 데이터들이 이 주소값들로 연결되어 있다고 보는 것이죠. 그리고 노드에 다음 요소의 주소값만 저장을 하면 이전 요소에 대한 접근이 어렵기 때문에 이전 노드의 주소값을 추가한 자료구조가 이중 연결리스트(Doubly Linked List)이며 자바의 LinkedList 컬렉션 클래스는 이중 연결리스트로 구현되어 있습니다.

```java
class Node {
	Node next;   // 다음 요소의 주소값
	Node prev;   // 이전 요소의 주소값
	Object obj;  // 데이터
}
```

`LinkedList`에 데이터를 추가하는 과정은 `ArrayList`보다 훨씬 간단합니다. 추가할 위치 이전 노드가 새로운 노드를 가리키면 되고, 새로운 노드가 원래 노드의 다음 노드를 가리키면 됩니다. 배열을 통째로 밀고 당기고 복사할 필요없이 `next`와 `prev`만 조작하면 쉽게 데이터를 추가할 수 있습니다.

`LinkedList`에서 삭제할 때는 더 쉽습니다. 삭제할 이전 노드가 삭제할 노드가 아닌 삭제할 다음 노드를 가리키면 되는거죠. 그래서 `LinkedList`는 비순차적인 데이터의 추가와 삭제가 정말 빠른 자료구조입니다. 하지만 데이터가 비순차적으로 저장되어 있기 때문에 임의의 데이터에 접근을 하려면 항상 처음부터 주소값을 따라가며 찾아야합니다. 

즉, **`LinkedList`는 비순차적인 데이터를 다룰때 유용한 자료구조**입니다. `ArrayList`와 변환이 가능하기 때문에 상황에 맞게 서로 변환하며 서로의 장점을 사용하여 작업을 하면 좋은 효율을 얻을 수 있을 것입니다. 다음은 `ArrayList`와 `LinkedList`를 비교한 표입니다.

| 컬렉션 | 읽기(접근) | 추가 / 삭제 | 주의사항 | 변환 |
| --- | --- | --- | --- | --- |
| ArrayList | 빠름 | 느림 | 순차적인 추가,삭제는 빠름 | ArrayList al = new ArrayList(ll); |
| LinkedList | 느림 | 빠름 | 데이터가 많아지면 접근성이 떨어짐 | LinkedList ll = new LinkedList(al); |

### Stack, Queue

많은 자료구조들 중에서 중요한 자료구조 5가지만 뽑아보라고 하면 그중에 반드시 포함되는 자료구조가 바로 스택(Stack)과 큐(Queue)입니다. 스택과 큐도 앞에서 배운 `ArrayList`와 `LinkedList`로 구현할 수 있습니다. 

스택은 한쪽에서만 데이터의 추가와 삭제가 이루어집니다. **스택**의 뒤에 순차적으로 데이터가 추가되고 순차적으로 데이터가 삭제되므로 **`ArrayList`를 사용하여 쉽게 구현이 가능**합니다. **큐**는 한쪽에서는 데이터가 삭제되고 다른 한쪽에서는 데이터가 추가됩니다. `ArrayList`를 사용하여 큐를 구현하면 데이터를 삭제할 때마다 배열의 복사가 발생하기 때문에 **데이터의 추가/삭제가 쉬운 `LinkedList`를 이용하여 더 효율적으로 구현할 수 있습니다.** 

 

### Arrays

배열에 대해서는 1권에서 배웠었기 때문에 내용에 대해서는 생략하고 여기서는 Arrays 클래스에 대해 조금 알아보려고 합니다. Arrays 클래스에는 배열을 다루는데 있어서 유용한 메서드들이 있습니다. 그 중에서 몇 가지만 정리를 해봤습니다. 

| 메서드 | 설명 | 예시 |
| --- | --- | --- |
| fill() | 배열의 모든 요소를 원하는 값으로 채운다. | Arrays.fill(arr, -1); |
| setAll() | 배열을 함수형 인터페이스를 이용하여 값들을 채운다. | Arrays.setAll(arr, ()→(int)(Math.random() * 5 + 1); |
| sort() | 배열을 정렬한다. (오름차순이 기본) | Arrays.sort(arr); |
| binarySearch() | 이진 탐색을 사용하여 배열에서 값을 검색. 오름차순으로 정렬되어 있어야 한다. | Arrays.binarySearch(arr, 3); |
| asList() | 배열을 리스트로 변환한다. | List list = Arrays.asList(arr); |

### Comparator와 Comparable

추후 추가

## Set

<aside>
💡 ***순서를 유지하지 않는 데이터의 집합. 중복을 허용하지 않는 데이터의 집합***

</aside>

### HashSet

`HashSet`은 `Set`의 대표적인 컬렉션입니다. `Set`의 특징대로 중복되는 데이터를 저장하지 않으며 순서 또한 유지하지 않습니다. 만약 순서를 유지하고 싶으면 `LinkedHashSet`을 사용하면 됩니다. 보통 배열에서 중복되는 요소를 제거하고 싶을 때 배열을 `Set`으로 바꾼뒤 다시 배열로 돌리는 작업을 많이 합니다.

Set의 메서드들은 List와 유사하기 때문에 메서드들에 대한 내용은 생략하고 `**HashSet`이 어떻게 데이터의 중복을 판별하는지 간단하게 원리를 알아보겠습니다.** HashSet에서 add메서드가 사용될 경우 새로운 데이터를 추가하기 전에 기존에 저장된 요소와 같은 것인지 확인하기 위해 **추가하려는 요소의 `equals()`와 `hashCode()`를 호출**합니다. 기본형의 경우 이 두 메서드는 구현이 되어있기 때문에 우리가 신경 써야될 때는 새로운 클래스에서 `Set`을 사용할 경우입니다. `equals()`와 `hashCode()` 모두를 오버라이딩 해주어야 하는데 `equals()`를 오버라이딩하는 것은 언급을 했었으니까 `hashCode()`를 어떻게 오버라이딩 해야 하는지에 대해 살펴보겠습니다.

- 같은 객체에 대해서는 `hashCode()`를 여러 번 실행하더라도 같은 값을 반환해야한다.
- `equals()`로 `true`인 두 객체는 `hashCode()` 값도 동일해야 한다.
- `equals()`로 `false`인 두 객체는 `hashCode()` 값이 동일해도 상관 없지만 성능을 위해 다른 값을 반환하는 것이 좋다.

즉, `equals()`와 `hashCode()` 값이 같아야하는 것이 핵심입니다. 마지막에 다른 객체라면 `hashCode()` 값이 다른 것이 성능에 더 좋다고 하였는데 이에 대한 이유는 잠시 뒤에 알아볼 **해싱(hashing)**을 통해 알 수 있습니다.

### TreeSet

앞에서 본 `HashSet`이 `Set` 인터페이스의 대표적인 컬렉션이라면 `TreeSet`은 조금 더 특별한 목적에 사용되는 컬렉션 입니다. 이름에서 알 수 있듯이 `TreeSet`은 데이터들을 `트리(tree)`, 그 중에서도 **`이진 검색 트리(Binary Search Tree, BST)`에 저장하여 데이터의 검색과 정렬의 성능을 향상시킨 컬렉션**입니다. 자바에서는 이진 검색 트리를 구현하는 여러 방법 중에서 성능이 좋은 `레드-블랙 트리(Red-Black tree, RB-tree)`로 `TreeSet`을 구현하였습니다.

간단하게 이진 검색 트리에 대하여 알아보겠습니다. 먼저 이진 트리는 각 노드의 자식이 최대 2개로 이루어진 트리를 의미합니다. 보통 `left`와 `right`로 부르는 자식들입니다. 이진 검색 트리는 이 **이진 트리에 ‘검색’의 기능을 넣은 자료구조**입니다. 이는 데이터를 조금 특별하게 저장하는 자료구조인데요. 바로 **자신보다 값이 큰 자식은 오른쪽에, 자신보다 값이 작은 자식은 왼쪽에 저장을 하는 것**입니다. 이렇게 저장을 하면 중위 순회를 통해 쉽게 오름차순으로 정렬된 데이터들의 집합을 얻을 수 있습니다. 그리고 데이터가 일관된 규칙에 따라 저장되어 있기 때문에 굉장히 빠르게 원하는 값을 검색할 수 있습니다.

이러한 이진 검색 트리의 특성을 생각해보면 당연하게도 중복된 값을 저장할 수 없겠구나라는 사실을 알 수 있습니다. 중복된 값은 왼쪽과 오른쪽, 그 어떤 쪽에도 저장이 불가능하기 때문이죠. 또, `TreeSet`은 데이터를 트리 구조로 저장을 하기 떄문에 값을 추가하거나 삭제하는데에 더 많은 시간이 소요됩니다. 

한 가지 주의해야할 점은, 우리가 원하는 기준으로도 데이터를 `TreeSet`에 정의할 수 있다는 것입니다. 위에서 배운 `Comparable`이나 `Comparator`를 통하여 어느 기준으로 데이터를 저장할지 `TreeSet`에 알려주면, `TreeSet`은 해당 기준으로 트리를 구성합니다.

## Map

<aside>
💡 ***키(key)와 값(value)의 쌍으로 이루어진 데이터들의 집합.***

</aside>

### HashMap, TreeMap

Map 인터페이스에는 HashMap과 TreeMap이 있습니다. 각각 HashSet, TreeSet과 동일하게 해싱과 이진 검색 트리를 이용하여 데이터를 저장하는 컬렉션들입니다. **키(key)값을 가지고 값(value)을 찾기 때문에 키 값이 중복이 되서는 안됩니다.** 어떠한 값을 반환해야할지 모르기 때문이죠. 이 점만 주의해서 사용하면 될 것 같습니다.

## Hashing

`HashSet`과 `HashMap`에 사용되는 **해싱(hashing)**에 대하여 간단하게 알아보겠습니다. **해싱은 해시함수(hash function)를 이용하여 데이터를 해시 테이블(hash table)에 저장하고 검색하는 기법**을 말합니다. 해시 테이블은 보통 배열과 링크드 리스트의 조합으로 이루어져 있고, 다음의 과정을 통하여 데이터를 검색합니다.

- 검색하고자 하는 데이터의 키(key)를 해시 함수(hash function)에 넣어 데이터가 어느 링크드 리스트에 저장되어 있는지 찾습니다.
- 해당 링크드 리스트로 가서 데이터를 찾습니다.

먼저, 키 값을 해시 함수에 넣어 데이터가 저장되어 있는 링크드 리스트가 어느 배열인지를 찾습니다. 이때 해시 함수로는 `hashCode()`를 사용합니다. 그리고 해당 링크드 리스트에서 데이터를 찾는데, 링크드 리스트는 위에서 말했듯이 데이터들이 비순차적으로 저장이 되어 있어 검색이 느린 자료구조입니다. 따라서 해시 함수가 중복된 해시 코드를 많이 생성해내면 링크드 리스트에도 많은 데이터가 저장되게 되고, 이는 데이터 검색이 느려지는 결과를 초래합니다. 이것이 위에서 언급했었던 키 값이 다르다면 hashCode()도 다른 것이 성능에 좋은 이유입니다. 이상적인 결과는 모든 키 값이 유니크한 해시 코드 값을 가지는 것이겠죠. 

이상으로 자바에서 사용하는 대표적인 컬렉션 프레임워크들에 대하여 알아봤습니다. 위의 컬렉션들은 자바 프로그래밍을 하면서 정말 많이 사용되기 때문에 많이 사용하시다보면 각 컬렉션들이 지원하는 메서드들도 자연스럽게 익히실 수 있을 것이라 생각합니다. 그러면 마지막으로 컬렉션의 요소들에 접근할 수 있는 인터페이스인 `Iterator`에 대해 설명하고 마무리하도록 하겠습니다.

## Iterator

`**Iterator`는 컬렉션에 저장된 요소들을 읽는 표준화된 방식**입니다. `Iterator`라는 인터페이스가 존재하고 이를 `Collection` 인터페이스가 포함하는 형태여서 모든 `Collection` 클래스에서 `Iterator`를 사용할 수 있습니다. `Map`의 경우에는 키 값에 대한 `iterator`를 통하여서 `Map`에 저장되어 있는 모든 요소들에 접근할 수 있습니다. 보통 `Iterator`를 사용하는 방법은 다음과 같습니다.

```java
Collectio c = new ArrayList();
Iterator it = c.iterator();

while (it.hasNext()) {
	System.out.println(it.next());
}
```

`ListIterator`는 `Iterator`를 상속받아 역방향으로의 접근 기능을 추가한 `iterator`이며, `Enumeration`은 `Iterator`의 구버전이므로 딱히 사용할 일이 없습니다.