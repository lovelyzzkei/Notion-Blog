# 람다와 스트림(Lambda & Stream)

2022.07.18

어느덧 자바의 정석 2권도 거의 마무리를 향해 가고 있습니다. 자바의 정석 2권의 경우 자바로 수행할 수 있는 여러 고급 기술들에 대하여 설명을 하고 있는데 오늘 설명할 람다와 스트림의 경우 지금의 상황에서 가장 유용하면서 고급 기술이라 말할 수 있는 기능들이라 생각합니다. 내용이 많이 복잡하고, 제가 느끼기에 아직 저에게 필요하지 않은 부분들도 많이 있다고 생각하여, 읽기는 다 읽었지만 추후 계속 공부를 해나가며 그때 그때 더 추가를 하는 식으로 글을 작성하려고 합니다. 오늘은 지금 시기에서 저에게 유용해보이는 것들을 위주로 정리를 해보겠습니다. 

시작하기 전에 이번 목차에서의 목표는 다음의 코드를 이해하는 것입니다.

```java
// 입력으로 들어오는 한 줄을 공백 기준으로 잘라 정수형 배열로 만드는 코드
int[] arr = Stream.of(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
```

## 람다식(Lambda expression)

**람다식(lambda expression)은 메서드를 하나의 식(expression)으로 표현한 것**을 말합니다. 메서드에서 이름과 반환값을 지우고 남은 식을 람다식이라고 볼 수 있겠습니다.

```java
int[] arr = new int[5];
Arrays.setAll(arr, () -> (int)(Math.random()*5 + 1));
```

`Arrays`의 `setAll` 메서드의 경우 람다식을 매개변수로 받아 해당 값으로 배열의 값을 채우는 메서드입니다. 직관으로 봐도 배열의 값들을 1에서 6사이의 임의의 값으로 채운다는 것을 알 수 있습니다. 만약 위의 작업을 `setAll` 메서드 대신 일반적인 `for`문을 이용해서 수행해야 한다면 다음과 같은 작업이 수행될 것입니다,

```java
for (int i = 0; i < arr.length; i++) {
	arr[i] = (int)(Math.random() * 5 + 1);
}
```

우리에게 있어서는 아직 `for`문이 더 익숙하지만 **람다식을 사용하면 더 간결하고 직관적인 코드**를 작성할 수 있고, **메서드를 변수처럼 다룰 수 있어서 하나의 메서드를 여러 곳에 사용할 수 있는 등 재사용성도 높일 수 있습니다.**

람다식을 작성하는 방법은 다음과 같습니다.

```java
~~반환타입 메서드이름~~ (매개변수) **->** {
	문장들
}
```

일반적으로 메서드를 선언하는 방식에서 반환타입과 메서드 이름을 지우고 매개변수와 문장들 사이에 → 를 넣어줍니다. 일반 메서드와 동일하게 문장이 하나일 경우 {}를 생략할 수 있으며 반환값이 있는 메서드일 경우 return문을 식으로 대체할 수 있습니다.

자바에서 모든 메서드는 클래스 내에 포함되어야 합니다. 그러면 람다식은 어떤 클래스에 포함되는 것일까요?

### 함수형 인터페이스(Functional Interface)

먼저 간단한 람다식을 하나 정의해보겠습니다.

```java
(int a, int b) -> a > b ? a : b
```

```java
new Object() {
	int max(int a, int b){
		return a > b ? a : b;
	}
}
```

위의 식은 a와 b 중 더 큰 값을 반환하는, Math.max(a, b)를 람다식으로 구현한 것입니다. 앞에서 말하기를 메서드를 변수처럼 사용할 수 있는 것이 람다식이라고 하였습니다. 그런데 사실 람다식은 익명 클래스의 객체와 동등합니다. 그러면 어떻게 이 객체의 메서드를 호출할 수 있을까요? 일단은 참조 변수가 있어야 객체의 메서드를 호출할 수 있으니 이 익명 객체의 주소를 f라는 참조 변수에 저장을 해봅시다. 

```java
타입 f = (int a, int b) -> a > b ? a : b;
```

그러면 이 참조 변수의 타입은 무엇일까요? 참조형이니까 클래스 또는 인터페이스가 가능할 것이고, 람다식과 동등한 메서드가 정의되어 있어야 합니다. 예를 들어, max()라는 메서드가 정의되어있는 MyFunction()이라는 인터페이스를 보죠. 

```java
interface MyFunction() {
	public abstract int max(int a, int b);
}
```

그러면 이 인터페이스를 이용해서 구현한 익명 객체는 다음과 같이 생성이 가능할 것입니다.

```java
MyFunction f = new MyFunction() {
									public int max(int a, int b) {
										return a > b ? a : b;
									}
								};
int big = f.max(5, 3);
```

근데 위의 객체의 메서드 max()는 처음에 정의했던 람다식의 익명 객체에서의 메서드 선언과 동일합니다. 따라서 위의 코드는 다음과 같이 대체할 수 있습니다.

```java
MyFunction f = (int a, int b) -> a > b ? a : b;
int big = f.max(5, 3);
```

즉, **람다식도 실제로 익명 객체이고, 인터페이스를 구현한 익명 객체의 메서드와 람다식의 매개변수의 타입과 개수 그리고 반환값이 일치하기 때문에 인터페이스를 구현한 익명 객체를 람다식으로 대체가 가능합니다.** 따라서 자바에서는 인터페이스를 통해 람다식을 다루기로 하였으며, **람다식을 다루기 위한 인터페이스를 함수형 인터페이스(functional interface)**라고 합니다. 

```java
@FunctionalInterface
interface MyFunction {
	public abstract int max(int a, int b);
}
```

보통 우리가 일반적으로 사용하는 메서드는 타입이 비슷하며 형식 또한 비슷하다고 할 수 있습니다. `java.util.function`에는 이렇게 자주 쓰이는 형식의 메서드를 함수형 인터페이스를 미리 정의해 놓았습니다. 이들을 이용하여 인터페이스끼리의 결합 등 더 많은 기능을 수행하는 메서드를 만들 수 있지만 지금으로서는 중요도가 낮다고 생각하여 넘어가도록 하겠습니다.

### 메서드 참조

우리는 람다식을 이용해서 메서드를 간단하게 작성하는 법을 배웠습니다. `java.util.function`에 있는 `Function` 인터페이스를 이용하여 간단하게 `String` 타입 변수를 `int` 타입으로 바꾸는 메서드를 하나 정의해보죠.

```java
Function<String, Integer> strToInt = (String s) -> Integer.parseInt(s);
```

그런데 람다식이 하나의 메서드만 호출할 경우 람다식을 여기서 더 간결하게 만들 수 있습니다.

```java
Function<String, Integer> strToInt = Integer::parseInt;
```

어차피 `Integer.parseInt()`는 하나의 `String` 타입의 변수만 받기 때문에 굳이 매개변수 부분을 나타낼 필요가 없다는 느낌입니다. 이렇게 **람다식이 하나의 메서드만 호출할 때 메서드를 `클래스이름::메서드이름` 또는 `참조변수::메서드이름` 으로 쓸 수 있는 기법을 메서드 참조(method reference)**라고 합니다.

## 스트림(stream)

우리는 보통 많은 수의 데이터를 다룰 때 `for`문 또는 `Iterator`문을 사용하여 데이터를 처리합니다. **스트림은 이러한 데이터 처리를 더 간결하고 일관성 있게 할 수 있도록 여러 메서드를 지원하는 클래스**입니다. 데이터 소스를 추상화하고, 데이터를 다루는데 자주 사용되는 메서드들을 정의해 놓아서 데이터 소스가 무엇이든, `Array`이든 `Collection`이든 같은 방식으로 다룰 수 있게 해줍니다.

예를 들어, 정렬의 경우 배열을 정렬할 때는 `Arrays` 클래스의 `sort()` 메서드를, 컬렉션 프레임워크를 정렬할 때는 `Collections` 클래스의 `sort()` 메서드를 이용해야 합니다. 하지만 스트림의 경우 두 데이터를 이용하여 `Stream` 객체를 생성하고 `Stream` 클래스 내에 있는 정렬 메서드를 사용할 수 있다는 것입니다. 훨씬 일관성이 생길 뿐더러 재사용성도 높아지는 코드인 것이죠.

데이터를 스트림화 시켜서 다룰 때는 몇 가지 주의해야할 점이 있습니다.

- 스트림은 **데이터 소스를 변경하지 않는다.**
    
    ```java
    Stream<String> strStream = Stream.of(br.readLine().split(" "));
    Stream<String> strStream = Arrays.stream(new String[] {"a", "b"});
    ```
    
    위와 같이 스트림을 만드는 데에는 여러 방법이 있습니다. 맨 처음에 봤던 `Stream.of()`를 사용하는 방법도 있고, 배열과 컬렉션에도 스트림을 만드는 `stream()` 메서드가 정의되어 있습니다. 이들 모두의 공통점은 기존 데이터에서 이들을 담고 있는 **스트림 객체**를 새로 만든다는 것입니다. 즉, 스트림 객체에 기존 데이터 소스가 모두 복사되어 있어 스트림에 정의되어 있는 메서드들은 이 데이터들을 조작하는 것입니다. 따라서, 스트림은 데이터 소스를 변경하지 않습니다.
    
- 스트림은 **일회용**이다.
    
    스트림은 일회성이기 때문에 한번 스트림의 요소를 읽으면 다시 읽을 수 없습니다. 
    
- 스트림은 작업을 **내부 반복**으로 처리한다.
    
    스트림이 for문 또는 Iterator문으로 처리하는 작업들을 간결하게 처리할 수 있는 이유는 이러한 반복들을 내부에서 처리하고 사용자에게는 해당 내용들을 숨기기 때문입니다. 
    

### 스트림의 연산

그러면 스트림이 지원하는 여러 데이터 처리 메서드들에 대하여 알아보죠. 그 전에 스트림의 연산은 크게 두 가지로 나뉩니다.

- 중간 연산: 스트림의 요소를 사용하여 **새로운 스트림을 생성.** filter() limit(), map() 등
- 최종 연산: 스트림의 요소를 소모하여 스트림이 아닌 **새로운 데이터를 생성.** forEach(), reduce(), collect() 등

위에서 말했듯이 스트림은 일회용이라 한번 사용되면 다시 사용이 불가합니다. 그래서 보통 스트림에 여러 중간 연산을 수행하여 스트림을 계속 연결하여 원하는 데이터들만 남기고, 여기에 최종 연산을 수행하여 해당 데이터들로 원하는 데이터를 생성하는 형식으로 스트림을 사용합니다. 

여기까지 보고 맨 처음에 봤던 코드를 다시 한 번 봅시다.

```java
int[] arr = Stream.of(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
```

이제 어느 정도 위의 코드가 해석이 되시나요? 차근차근 살펴보겠습니다.

1. `Stream.of(br.readLine().split(” “))` : `br.readLine().split(” “)`으로 생성된 `String` 타입의 배열을 가지고 String 타입의 Stream 객체를 생성합니다.
2. `mapToInt(Integer::parseInt)` : `map()` 아직 설명하지 않았지만 `Stream` 내의 요소들을 특정 형태로 변환 또는 특정 값들만 뽑아내는 중간연산입니다. `map()`의 경우 함수형 인터페이스 또는 람다식을 매개변수로 받는데 아까 봤던 메서드 참조인 `Integer::parseInt`가 매개변수로 넘어갔습니다. 즉, `Stream` 내의 요소들을 하나씩 받아 `int`로 형변환을 한다는 것입니다.
3. `toArray()`: 위의 두 연산의 결과는 어쨌든 스트림입니다. 이제는 모든 작업이 끝났으니 이를 배열로 바꿔야겠죠. `toArray()`는 스트림을 배열로 바꿔주는 최종 연산입니다. 

스트림을 사용하는 방법이 어느 정도 감이 잡히시나요? 스트림에는 제가 지금 말한 것보다 훨씬 많은 유용한 연산들이 있습니다. 지금은 여기까지 정리를 하고 계속 공부를 하면서 정리가 필요하다고 생각되는 부분들은 다시 또 정리하도록 하겠습니다. 

<aside>
💡 **데이터를 다룰 때는 스트림을 한번 이용해보자!!!**

</aside>