# Thread

앞에서 나름 자세하게 OS의 가장 기본이 되는 프로세스에 대하여 알아봤습니다. 프로세스는 현재 실행중인 프로그램이며 이미지와 프로세스 문맥으로 이루어져 있죠. 그리고 여러 프로세스를 동시에 실행하는 멀티 프로세싱도 간단하게 언급을 했었습니다.

이 멀티 프로세싱을 조금 더 살펴보죠. 동일한 프로그램을 멀티 프로세싱으로 처리한다고 했을 때 각 프로세스가 동일한 이미지를 갖고 있습니다. 이들이 중복되는 것이라면 공유를 할 수도 있지 않을까요? 프로세스를 만드는 유일한 `system call`인 `fork()`를 수행하게 되면 부모 프로세스의 이미지와 프로세스 문맥 모든 것이 새로 만들어지게 됩니다. **꽤나 무거운 작업인 것이죠(heavy-weight model).** 프로세스끼리 중복되는 부분을 공유한다면 자원을 더 효율적으로 사용하여 최적화에 도움이 될 수 있을 것입니다. 

그리고 또 하나 짚고 싶은 것은, 과연 프로세스들이 ‘멀티’, 즉 병렬화가 이루어져 처리가 되는 것일까요? 지금의 프로세스들은 그렇지 않지만 옛날의 프로세스들은 멀티 프로세싱으로 구현을 하여도 **멀티 프로세서(multiprocessor)의 이점을 전혀 얻지 못하였습니다.** 프로세스가 한번에 하나의 프로세서만 사용할 수 있었기 때문이죠. 

이러한 문제점에서 프로세스보다 더 효율적이면서 가벼운 개념의 프로그램 모델에 대한 논의가 등장하였습니다. 그리고 그 결과로 등장한 것이 바로 **멀티 스레딩(MultiThreading)**입니다.

## Thread

멀티 스레딩은 스레드(thread)를 동시에 여러 개 실행하는 개념입니다. 그러면 스레드는 무엇일까요? 스레드는 ‘실’을 의미하는 영단어 입니다. 컴퓨팅 영역에서는 다음의 의미로 사용됩니다.

<aside>
💡 ***프로세스 안에서 실행되는 프로그램의 흐름의 단위 (A sequence of instructions being executed in a program)***

</aside>

![Untitled](Thread%202e00c7dbc2104668a8c3a304f6fc60de/Untitled.png)

스레드 개념은 위의 멀티 프로세싱의 단점에서 등장한 개념입니다. 즉, 프로세스들끼리 중복되는 부분을 없애자라는 생각에서 등장한 것이죠. 그래서 스레드에는 각 프로세스의 고유한 정보들인 `user stack`과 `program context` 부분만 존재합니다. 그리고 **중복되는 이미지 부분을 모든 스레드가 공유하는 형태로 빼버렸습니다.** 그러면 더 이상 여러 개의 프로세스가 있을 필요가 없습니다. 단 하나의 프로세스만 있으면 되겠죠. 그래서 스레드의 정의에 **‘프로세스 안에서’**라는 말이 있는 것입니다.

![Untitled](Thread%202e00c7dbc2104668a8c3a304f6fc60de/Untitled%201.png)

스레드 이름 그대로 실 뭉치를 생각해보면 좋을 것 같습니다. 아래에는 여러 개의 실가닥들이 있고, 그 위에는 아래의 실가닥들을 묶는 실 뭉치가 있는 것이죠. 여기서 **아래의 실 가닥들이 각각의 스레드**이고 위의 실 뭉치가 스레드들이 공유하는 부분, 앞에서 멀티 프로세싱의 문제점으로 얘기하였던 **이미지 부분**을 의미합니다. 그리고 이 **실 뭉치 전체가 하나의 프로세스**입니다.

물론 데이터의 무결성(integrity) 문제가 존재하기는 합니다. 여러 스레드가 동시에 공유 데이터에 접근하여 읽거나 쓰기를 한다면 **동기화(synchronization)의 문제**가 존재하죠. 이는 후에 동기화 파트에서 다루도록 하고 지금은 프로세스보다 더 가벼운 신기술인 스레드에 대하여 조금 더 알아봅시다.

## Process vs Thread

스레드와 프로세스를 한번 비교해보죠. 이제 프로세스는 스레드를 담는 하나의 컨테이너가 되었습니다. 스레드는 하나의 프로세스에 bound 되고, 하나의 프로세스는 여러 개의 스레드를 가질 수 있습니다. 그리고 스레드가 프로세스의 단점에서 생긴 개념인 만큼 프로세스보다 **생성, 전환 등에 있어 더 경제적**입니다(less expensive). 또, 동일한 자원을 공유하기 때문에 스레드간 통신도 더 편하고, 이제는 하나의 프로세스 안에 여러 개의 스레드가 있기 때문에 **각 스레드가 서로 다른 프로세서에서 수행될 수 있습니다.** 이제서야 멀티 프로세서의 이점을 제대로 살릴 수 있는 것이죠.

하지만 모든 멀티 프로세싱이 멀티 스레딩으로 바뀌지는 않았습니다. 왜일까요? 위에서도 말했듯, 동기화의 이슈가 크게 작용합니다. 공유 데이터에 대한 race condition이나 메모리 관리 등 신경쓸 것이 많고, 이는 멀티 프로세싱보다 불안정하다는 것을 의미하기도 합니다. 그래서 여전히 멀티 프로세싱 모델도 사용되는 것입니다.

## Implementing Thread

그러면 스레드를 어떻게 구현할 수 있을까요? 크게 두 가지 방법이 있습니다.

### User-level

첫째는 사용자의 레벨에서, 즉 **라이브러리**를 만들어서 커널 모르게 스레드를 만들어쓰자는 생각입니다. 이는 구현이 쉽고 사용자가 원하는 대로 스레드를 구현할 수 있습니다. 하지만 커널이 이를 모르기 때문에 하나의 프로세스 안에 많은 스레드가 있다고 하더라도 **커널은 여전히 이를 하나의 프로세스로만 인지**를 합니다. 멀티 프로세서의 이점을 전혀 살릴 수 없고, 하나의 스레드가 block 당하면 모든 스레드가 block 되기 때문에 멀티 스레딩이라고 말할 수가 없습니다. 

### Kernel-level

결국은 OS가 지원을 해야되는 것입니다. 커널이 프로세스와 스레드에 대한 모든 정보를 알고 있어야 **스레드도 CPU 스케쥴링을 할 수 있고** 멀티 스레딩을 할 수 있는 것이지요. 그래서 **User-level의 스레드가 Kernel-level의 스레드와 일대일로 매핑이 되는** `one-to-one` **모델로 구현을 합니다.** 이렇게 할 경우 커널도 모든 스레드에 대한 정보를 알기 때문에 여러 스레드를 동시에 돌릴 수 있고, 하나의 스레드가 block 되더라도 다른 스레드에는 영향이 없습니다. 물론 이는 커널을 손봐야한다는 단점이 있지만, 이에 비해 얻는 이득이 더 많아 대부분의 OS에서 이를 지원합니다. 

## Linux Thread

그러면 우리가 지금 다루는 OS인 Linux에서는 스레드를 어떻게 구현하였을까요? Linux 개발자들은 기존 멀티 프로세싱의 구조를 최대한 바꾸지 않으면서 멀티 스레딩을 지원하고 싶었습니다. 그래서 이들은 `fork()` system call과 유사한 `clone()` 으로 스레드 생성을 구현하였습니다.

이들은 기존의 프로세스&스레드 개념 대신 `task` **라는 lightweight process 개념을 도입하여** `clone()` **으로 새로운 task를 생성하며, 부모와의 공유 정도를 인자로 넘겨서 멀티 스레딩을 구현하였습니다.** 이것이 가능한 이유는 Linux는 `PCB`인 `task_struct` 자료구조에 데이터를 모두 저장하는 것이 아니라 **데이터를 가리키는 포인터를 저장하고 있기 때문**입니다. 따라서 데이터를 복사하는 대신에 새로운 데이터를 가리키는 것으로 적은 overload로 새로운 task를 만들 수 있었습니다.