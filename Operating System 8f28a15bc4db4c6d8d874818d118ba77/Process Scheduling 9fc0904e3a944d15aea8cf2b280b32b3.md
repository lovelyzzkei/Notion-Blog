# Process Scheduling

프로세스와 스레드까지 컴퓨터에서 프로그램이 실행되는 기본 개념들에 대하여 알아봤습니다. 그 중에서 멀티 스레딩을 얘기하면서 프로세스 안의 각각의 스레드 역시 CPU 스케쥴링의 대상이 되기 때문에 멀티 프로세서의 이점을 제대로 살릴 수 있다라는 이야기를 한 적이 있는데요. 이번 시간에는 이 **스케쥴링**에 대한 이야기를 해보려고 합니다. 

## Basic Concepts

![Untitled](Process%20Scheduling%209fc0904e3a944d15aea8cf2b280b32b3/Untitled.png)

우리가 실행시키고 싶은 프로그램들은 너무나 많습니다. 크롬도 실행하면서 VS Code도 켜놓고 그 와중에 강의 자료들 인쇄도 하고 말이죠. 하지만 우리가 가지고 있는 **자원(resource)들은 너무나 한정적**입니다. 프로세서도 한 번에 하나의 프로세스만 처리할 수 있고 프린트를 하는 것도 한 번에 하나의 자료만 인쇄할 수 있죠. 이렇게 리소스를 쓰려고 하는 프로세스들을  *job* 또는 *request*라고 부릅니다. 그리고 이 *request*들은 *queue*에 임시로 저장되어 리소스를 사용하기를 기다립니다. 이들 중에는 다른 *request* 보다 먼저 처리되어야 하는 *request*도 있을 수 있고, 그렇지 않고 천천히 처리가 되어도 상관 없는 *request*도 있을 수 있습니다. 

리소스에도 두 가지 종류가 있습니다. *request*가 실행되는 **중간에 그 리소스를 뺏을 수 있는 *preemptible*한 리소스**와 *request*가 모두 실행될 때까지 **리소스를 뺏을 수 없는 *nonpreemtible*한 리소스**가 있습니다.

**스케쥴링은 *request*들을 *queue*에 넣고 우선순위대로 리소스를 사용하며 *request*들을 처리하는 알고리즘**을 의미합니다. 그러면 근본적으로 드는 생각이 있죠.

> ***어떤 request를 언제 수행할 것인가?***
> 

이번 챕터에서는 리소스가 어떻게 *request*들을 스케쥴링 하는지, 특히 **CPU가 어떻게 많은 프로세스들을 스케쥴링하여 처리하는지** 그 철학과 여러 알고리즘들에 대하여 알아보겠습니다.

## CPU Scheduling

![Untitled](Process%20Scheduling%209fc0904e3a944d15aea8cf2b280b32b3/Untitled%201.png)

***CPU Scheduling***의 목적은 *queue*에 있는, 특히 프로세스들이 대기하는 이 *queue*를 *ready queue*라고 부르는데, 이 ***ready queue*에 있는 프로세스 중 다음에 실행될 프로세스를 정하는 것**입니다. 이를 결정해주는 것이 *scheduler(dispatcher)*인 것이죠. 당연히 다음 프로세스를 빨리 결정할수록 전체적인 성능은 증가할 것입니다. 다른 말로 ***dispatch latency*가 작을 수록 좋은 것**이죠.

그러면 어떻게 다음 프로세스를 정할 수 있을까요? 일단 사용자와 CPU가 우선시하는 것이 다릅니다. **CPU는 최대한 노는 리소스가 없도록 하는 것이 중요**합니다*(high utilization)*. 그리고 최대한 많은 프로세스가 한 타임에 처리되는 것이 중요하죠(*high throughput*). CPU는 전체의 관점에서 모든 프로세스를 관리하는 것입니다*(CPU Oriented)*. 

하지만 **사용자는 자신의 프로세스가 중요**합니다*(Process Oriented)*. 내 프로세스의 결과가 나오는데 걸리는 시간이 짧으면 좋겠고*(Turnaround time)*, 내 프로세스가 먼저 처리되면 좋겠고*(Waiting time),* 내 프로세스가 더 빨리 응답되면 좋다는 생각을 갖습니다*(Response time)*. 그래서 이 둘은 양립이 불가능합니다. OS가 이 둘을 모두 만족시키는 것은 굉장히 어려운 일인 것이죠.

## Process Behavior

우리는 운영체제에 대하여 공부하고 있기 때문에 커널의 관점에서 *scheduling*하는 것을 생각해봅시다. 결과적으로 커널이 프로세스들을 잘 *scheduling*해야 나의 프로세스도 더 빨리 처리가 될 수 있겠죠? 프로세스는 실행되는데에 있어서 크게 두 가지로 분류할 수 있습니다. 첫째는 **CPU가 처리하는 시간이 큰 *CPU-bound* 프로세스**입니다. 둘째는 **사용자의 I/O에 많은 시간을 사용하는 *I/O-bound* 프로세스**입니다. 

만약에 스케쥴러가 프로세스들의 모든 행동을 알고 있다면, A라는 프로세스는 *CPU-bound*이고, B라는 프로세스는 *I/O-bound*라는 것을 미리 다 알고 있다면 이들을 적절히 스케쥴링하여 최상의 스케쥴링을 만들 수 있을 것입니다. 하지만 어떠한 프로세스가 *ready queue*에 들어올지 모르고, 프로세스가 실행되기 전까지 이들이 어떠한 *bound*인지 알 방법이 없습니다. 결국에는 ***runtime*에 이를 빠르게 캐치하는 것이 가장 이상적이며 어느 한쪽에 편향되지 않도록 잘 *scheduling*하는 것이 중요**합니다.

## Priority

그렇다면 결국에 중요한 것은 **어떤 프로세스를 고를 것인가**에 대한 문제입니다. 바로 ***priority*, *selection funciton*에 대한 문제**이죠. 모든 프로세스에는 각자의 *priority*가 존재할 것입니다. 그리고 그 *priority*에 따라 각 프로세스가 실행될 것이죠. 가장 쉽게 생각할 수 있는 것은 *priority*가 높은 프로세스를 먼저 처리하는 것입니다. 하지만, 우선순위가 높은 프로세스가 계속 들어오면 ***priority*가 낮은 프로세스들은 영원히 실행되지 않을 수 있는 *starvation*의 문제**가 존재합니다. 

따라서 시간이 지남에 따라 **우선순위가 낮은 *request*들의 우선순위를 높여줌**으로써 모든 *request*들이 처리될 수 있는 ***Dynamic Priority*기법**이 주로 사용됩니다. 

## Decision Mode

그렇다면 어떤 프로세스를 고를 것인지는 정했고 그러면 이제 언제 프로세스를 고를 것인가에 대하여 알아보죠. 앞에서 리소스에는 ***preemptive***한 리소스와 ***nonpreemptive***한 리소스가 있다고 얘기했었죠. 마찬가지고 프로세스를 고르는 것도 ***preemptive***하게 또는 ***nonpreemptive***하게 고를 수 있습니다.

![Untitled](Process%20Scheduling%209fc0904e3a944d15aea8cf2b280b32b3/Untitled%202.png)

- ***nonpreemptive***: **현재 프로세스가 끝나거나 *I/O block*이 발생**할 경우 다음 프로세스를 골라서 실행
- ***preemptive***: 현재 프로세스의 ***time-quantum*이 끝나거나** ***waiting*에 있던 프로세스가 다시 *ready* 상태로 돌아올 때**, 현재 프로세스에 *interrupt*를 걸어 우선순위가 더 높은 프로세스를 실행시킬 수도 있습니다. 즉, **하나의 프로세스가 리소스를 독점하지 못하게 하는 것**이죠. 대부분의 스케쥴러가 이와 같은 형태로 프로세스를 고릅니다.

그러면 이제 이전에 사용했었던 ***scheduling algorithm***들에 대하여 알아봅시다!

## Legacy Scheduling

### First-Come First-Served(FCFS)

먼저는 큐와 비슷하게 먼저 들어온 request를 먼저 처리하는 FCFS입니다.

- Selection function: 이름에서 알 수 있듯이 먼저 들어온 것을 먼저 처리
- Decision mode: nonpreemptive