# Process

Intro 에서 한번 언급했었지만, 우리가 실행하는 모든 프로그램은 프로세스입니다. 이번 시간에는 우리가 컴퓨터로 프로그램들을 실행할 때 OS가 이를 어떻게 관리하는지 프로세스에 대하여 알아보겠습니다. 

## Process

<aside>
💡 ***Process is an instance of a running program***

</aside>

프로세스는 현재 컴퓨터에서 실행중인 프로그램을 의미합니다. 크롬으로 웹서핑을 한다고 생각해봅시다. 먼저 크롬을 설치를 해야겠죠. 이는 우리의 저장장치인 SSD나 HDD에 설치가 될 것입니다. 바탕화면에 크롬 아이콘이 생성되고 이를 더블 클릭하여 우리는 크롬을 실행시킵니다. 그러면 저장장치에 있는 크롬이 **RAM에 올라와 CPU가 실행할 수 있는 상태로 바뀌면서 크롬이 실행됩니다.** 이렇게 하나의 프로세스가 생성이 되었습니다.

![Untitled](Process%202b4e002e7e754973a125c3e1d89e80af/Untitled.png)

이를 간단하게 확인할 수 있는 곳이 바로 작업 관리자입니다. 여기에서는 친절하게 **프로세스**라는 탭이 따로 존재하고 여기에서 **현재 실행중인 프로그램들, 즉 프로세스들**을 확인할 수 있습니다.

참고로, 현재 저는 13개의 크롬 탭을 실행시키고 있는데요. 위의 작업 관리자 사진에서 Chrome(13)을 통해 이를 확인할 수 있습니다. 뒤에서 다시 언급하겠지만 이는 크롬의 멀티 탭이 **멀티 프로세싱으로 실행된다**는 것을 알 수 있는 부분입니다.

**프로세스는 크게 `이미지(Image)`와 `프로세스 정보(Process context)`으로 구성**됩니다. 하나씩 살펴보죠.

## Image

![Untitled](Process%202b4e002e7e754973a125c3e1d89e80af/Untitled%201.png)

**이미지(Image)는 프로그램이 RAM에 올라와있는 그 레이아웃**을 의미합니다. 크게 4가지 영역으로 구분되는데 각각의 영역은 다음과 같습니다.

- Stack: 프로그램을 실행하면서 사용되는 파라미터나 로컬 변수 등 일시적인 변수들의 저장 공간
- Heap: 프로그램을 실행하면서 동적으로 할당되는 메모리를 위한 공간
- Data: 전역 변수들이 저장되는 공간
- Text: 프로그램의 코드가 저장되는 공간

우리가 코드에 include하는 라이브러리도 스택에 쌓입니다. 즉, **프로세스가 실행되면서 필요한 모든 것들이 이미지에 존재합니다.**

## Process Context

프로세스 문맥(Process Context)은 말 그대로 흐름, 현재 프로세스가 실행되면서 기억해야 할 상태들에 대한 정보를 저장하고 있습니다. 여기에는 두 종류가 존재합니다.

- **Program Context** : data registers, program counter, stack pointer 등 **runtime에서의 정보**
- **Kernel Context** : PID, GID, SID, **process state**, VM structure 등 **user와 kernel mode를 switching 하는데 있어서 보존되어야 하는 값들, 필요한 값들 등등** (여러 process의 time-sharing)

프로세스는 이렇게 프로세스가 돌적에 필요한 모든 정보들을 담고 있는 이미지와 그 프로세스가 지금 어떤 상태로 돌고 있는지를 저장하는 프로세스 문맥으로 구성됩니다. 하지만 위에서도 잠깐 언급했듯이 우리가 실행하는 프로그램은 한개가 아닙니다. 위의 작업 관리자 사진만 봐도 100개가 넘는 프로세스가 동시에 실행이 되고 있습니다.

이렇듯 프로세스는 동시에 여러 개가 존재할 수 있기 때문에 프로세스가 실행에 필요한 정보들, 즉 **Image와 Program Context를 저장하고 보관할 자료구조가** 필요합니다. 그 자료구조를 **Process Control Block, 줄여서 PCB**라고 부릅니다.

## Process State

여러 개의 프로세스가 존재할 수 있지만, CPU는 매 순간 최대 하나의 프로세스만 처리가 가능합니다. 멀티태스킹이라는 것이 우리 눈에는 동시에 여러 작업을 하는 것처럼 보이지만 실제로는 매우 빠른 속도로 전환하면서 착각을 일으키는 것과 같은 것이죠. 따라서, 우리는 **매 순간 어떤 프로세스를 수행할지 정해야하며**, 이는 후에 설명할 **스케쥴링(Scheduling)**과 밀접합니다.

그 전에, 일단 프로세스가 수행이 되려면 **수행 가능한 상태**에 놓여야겠죠. 막 만들어진 프로세스가 바로 수행될 수는 없기 때문입니다. 이렇게 **현재 프로세스의 상태를 알려주는 것이 `Process State`**입니다. 다음의 표는 프로세스가 가질 수 있는 상태와 그 관계에 대하여 설명하고 있습니다.

![Untitled](Process%202b4e002e7e754973a125c3e1d89e80af/Untitled%202.png)

## Process Switching

위의 Process State를 보면 running에 있는 프로세스가 timeout 되면 다시 ready로 돌아가고 새로운 프로세스가 CPU에서 실행이 됩니다. 그러면 **이전의 프로세스가 가지고 있던 Control 등을 새로운 프로세스에게 잘 넘겨줘야 합니다.** 여기서 등장하는 것이 바로 `Process Switching`입니다.

그러면 Process Switching은 어떻게 발생하며, Process Switching과 앞서 말한 Mode Switching은 어떻게 다른 것일까요?

`Mode Switching`은 **User mode와 Kernel mode 사이를 왔다갔다 하는 것**으로, 이전에 봤듯이 external interrupt(timer, I/O), Internal trap(exception), System Call 등에 의해 발생합니다. 하나의 프로세스가 실행되는 데에도 정말 많은 Mode Switching이 발생하며 이때 Process State가 바뀔 경우 Mode Switching 이후에 Process Switching이 발생합니다. 

Mode Switching은 현재 processor의 상태를 저장하고 잠시 갔다오면 되는 반면에, **Process Switching은 실행하고 있는 PCB 자체를 바꿔야합니다.** 이는 현재 상태의 이미지를 저장하고 실행시킬 프로세스의 이미지를 복원하는 작업이 필요하기 때문에 Mode Switching보다 더 복잡하고 Overhead가 큽니다.

## Execution of the Operating System

![Untitled](Process%202b4e002e7e754973a125c3e1d89e80af/Untitled%203.png)

우리가 컴퓨터로 많은 프로그램들을 실행시키지만 그 기저에 컴퓨터가 켜져있는 동안 항상 돌아가고 있는 프로그램이 있습니다. 바로 운영체제이죠! 윈도우나 맥OS는 컴퓨터를 키는 그 시점부터 끄는 시점까지 계속해서 돌아갑니다. 그러면 OS도 하나의 프로세스라고 생각할 수 있는데, 어떻게 구현을 할 수 있을까요? 우리가 실행하는 프로세스와 계속해서 Process Switching이 발생하는 것일까요?

Process Switching으로 구현을 하면 매 순간마다 OS의 정보를 저장하고 PCB를 교체하고 사용자의 프로세스로 갔다가 또 왔다가를 반복해야합니다. 꽤 Overhead가 클 것이라 예상되죠. 그래서 **OS는 사용자의 프로세스 내부에서 같이 돌아가는 형태로 구현이 됩니다.** 32bit로 가정을 하면 약 1GB정도의 메모리를 OS에게 할당하여 그 안에서 커널 코드가 수행되도록 구현이 됩니다. 이렇게 구현을 할 경우 메모리 주소만 왔다갔다만 하면 되니까 훨씬 Overhead가 줄어들죠!

하지만 위와 같이 구현을 하면 사용자의 프로세스가 자신에게 주어진 메모리를 온전하게 사용하지 못한다는 단점이 있습니다. 레디 큐에서 기껏 기다려서 이제 Running의 상태가 되었는데 메모리를 다 쓰지 못한다면 사용자의 프로세스의 기분이 좋지 않겠죠.. 그럼에도 이렇게 구현을 하는 것은 유저의 프로세스는 커널 모드를 굉장히 많이 왔다갔다 하고(1초에 1000번) Mode Switching이 굉장히 빠르기 때문입니다. 많은 양의 Mode Switching을 감당하기 위해서는 **사용자의 프로세스 안에 커널 코드를 넣고 돌리는 것이 훨씬 더 효율적인 것**입니다.

## Creating Process

프로세스는 어떻게 만들어질까요? 아 물론 사용자의 입장에서는 프로그램을 누르기만 하면 실행이 되는 것처럼 보입니다. 하지만 여기서 다루고 싶은 것은 커널의 관점에서 프로세스가 생성되는 과정입니다. 

실행되는 **모든 프로세스는 트리의 구조**를 이룹니다. 컴퓨터가 켜질때 `init`이라는 프로세스가 실행이 되고 그 밑으로 여러 프로세스들이 만들어지고 종료됩니다. 이를 통해 말하고 싶은 것은 **프로세스는 수직적 관계를 이룬다**는 것입니다. 즉, 부모 프로세스(parent process) 없이는 자식 프로세스(child process)가 만들어질 수 없다는 것이죠. 그래서 **사용자는 부모 프로세스에서 `fork()`라는 system call을 통하여 새로운 프로세스를 만들 수 있습니다.** 그리고 이는 **사용자가 프로세스를 만들 수 있는 유일한 방법입니다.**

프로세스를 만드는데 필요한 몇개의 system call을 한번 보겠습니다.

### fork()

부모 프로세스에서 `fork()`를 부르면 **PID를 제외한 부모 프로세스의 복사본 프로세스가 생성**됩니다. 이때 stack과 heap의 데이터도 동일하게 복사됩니다. 이것이 자식 프로세스의 시초입니다. **부모는 fork()의 반환값으로 자식의 PID값을 반환하며 자식은 0을 반환**합니다. 이를 통해서 부모와 자식 프로세스를 구분할 수 있죠.

프로세스의 복사본을 만든다는 점에 있어서 `fork()`는 무거운 system call입니다. 그리고 매 순간 프로세스는 굉장히 많이 만들어지죠. 그래서 여기에 들어가는 자원을 효율적으로 사용하기 위하여 `copy-on-write`라는 기술을 사용합니다. **부모나 자식이 page에 쓰기 작업을 할 때 프로세스를 복사**하여 자원의 Overhead를 줄일 수 있습니다.

### exec()

그런데 우리가 실행하는 프로그램은 모두 다른 프로그램입니다. 부모 프로세스와 같은 프로세스가 아니라는 말이죠. 즉, 복사된 부모 프로세스를 사용자가 원하는 프로그램으로 바꿔주어야 합니다. 이를 수행해주는 `system call`이 `exec()`입니다. **기존에 수행되던 프로세스의 이미지를 새로운 프로그램의 이미지로 대체시켜주어 자식 프로세스가 생성됩니다.** 그리고 `fork()`와 `exec()`을 섞어서 사용하면 그것이 바로 멀티 프로세싱(multiprocessing)인 것이죠!

### exit()

이름에서 알 수 있듯이 프로세스를 종료하는 system call 입니다. 현재 프로세스를 비우고 커널로 돌아가죠. `fork()`의 역순입니다.

### wait()

얘도 이름에서 알 수 있듯이 무언가를 기다리는데 사용하는 system call 인데요. 주로 자식 프로세스가 끝날 때까지 부모 프로세스가 기다려야하는 경우, 즉, **부모와 자식간의 동기화가 필요한 경우 사용**됩니다. 앞에서 말한 멀티 프로세싱에서 주로 사용됩니다.

## Process Coordination

프로세스의 마지막으로 프로세스간 통신에 대하여 간단히 살펴보고 마무리 하겠습니다. 여러 개의 프로세스가 만들어지면 이들이 제각각 돌지는 않을 것입니다. 서로간의 주고 받는 데이터가 있을 수도 있고, 공유 자원을 사용한다면 동기화의 문제도 존재합니다. 동기화는 뒤에서 더 자세하게 살펴보도록 하고, 여기서는 **프로세스간 통신, IPC(Inter-Process Communication)**에 대하여 알아보겠습니다. 

### Pipe

프로세스끼리 데이터를 주고 받는데에 있어 `pipe`라는 것을 사용할 수 있습니다. 말 그대로 하나의 관이라고 생각하면 되는데요. **한 프로세스가 `pipe`에 데이터를 쓰면 다른 프로세스는 `pipe`에서 데이터를 읽어올 수 있습니다.** `pipe`를 생성하면 하나의 파일이 생성이 되고, 프로세스들이 해당 파일에 데이터를 읽고 쓰는 개념입니다. 하지만 일반 `pipe`는 부모와 자식 사이에서만 통신이 가능하므로 조금 더 다양한 프로세스들이 통신을 하려면 `named pipe`라는 것을 사용해야 합니다.

### Client-Server IPC & Socket

하지만 `pipe`는 단일 PC에서만 가능한 통신 방법입니다. 사람들은 다른 PC 사이의 프로세스간 통신도 하고 싶었고, 그렇게 등장한 것이 `Socket API` 입니다.